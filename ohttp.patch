diff --git a/components/cronet/BUILD.gn b/components/cronet/BUILD.gn
index 92350cf3b4b77..685dd0a147bca 100644
--- a/components/cronet/BUILD.gn
+++ b/components/cronet/BUILD.gn
@@ -275,6 +275,7 @@ if (is_android) {
     deps = [
       "//components/cronet",
       "//components/cronet/native:cronet_native_headers",
+      "//third_party/boringssl",
     ]
     if ((is_linux || is_chromeos) && !is_component_build) {
       public_configs = [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
diff --git a/components/cronet/native/sample/main.cc b/components/cronet/native/sample/main.cc
index 007d5bbab90d7..0276c927c29df 100644
--- a/components/cronet/native/sample/main.cc
+++ b/components/cronet/native/sample/main.cc
@@ -3,46 +3,33 @@
 // found in the LICENSE file.
 
 #include <iostream>
+#include <vector>
+#include <string>
+#include <cstdint>
 
 #include "cronet_c.h"
 #include "sample_executor.h"
 #include "sample_url_request_callback.h"
+#include "third_party/boringssl/src/include/openssl/hpke.h"
 
 Cronet_EnginePtr CreateCronetEngine() {
   Cronet_EnginePtr cronet_engine = Cronet_Engine_Create();
   Cronet_EngineParamsPtr engine_params = Cronet_EngineParams_Create();
   Cronet_EngineParams_user_agent_set(engine_params, "CronetSample/1");
 
-  Cronet_EngineParams_envoy_url_set(engine_params,
-                                    "https://example.com/enovy_path/");
+  // Standard HTTPS Proxy using Envoy's ansible roles.
   Cronet_EngineParams_envoy_url_set(
       engine_params,
       "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&resolve=MAP%20example.com%201.2.3.4");
-  // only MAP url-host to address
+      "?url=https%3A%2F%2Fenvoy-proxies.jthess.com%2Fenvoy_proxy_path%2F&header_Host="
+      "ohttp-gateway.jthess.com");
   Cronet_EngineParams_envoy_url_set(
       engine_params,
       "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&address=1.2.3.4");
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&address=1.2.3.4&disabled_cipher_suites=0xc024,0xc02f");
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&address=1.2.3.4&disabled_cipher_suites=0xc024,0xc02f");
-  Cronet_EngineParams_envoy_url_set(engine_params, "socks5://127.0.0.1:1080");
-  // proxy URL and SOCKS5 together (for true PTs)
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Frayon.example.com%2Fwikipedia%2F&address=142.65.13.41"
-      "&header_Host=abc.example.com&socks5=socks5%3A%2F%2Flocalhost%3A8192");
+      "?url=https%3A%2F%2Fohttp-relay.jthess.com" // Relay
+      "&ohttp=1" // Flag to indicate this is an ohttp relay
+      "&ohttp_gateway=ohttp-gateway.jthess.com"   // Explicit Gateway
+  );
  
   Cronet_EngineParams_enable_quic_set(engine_params, true);
 
@@ -72,6 +59,7 @@ void PerformRequest(Cronet_EnginePtr cronet_engine,
             << url_request_callback.response_as_string() << std::endl;
 }
 
+
 // Download a resource from the Internet. Optional argument must specify
 // a valid URL.
 int main(int argc, const char* argv[]) {
@@ -80,7 +68,7 @@ int main(int argc, const char* argv[]) {
   std::cout << "Cronet version: "
             << Cronet_Engine_GetVersionString(cronet_engine) << std::endl;
 
-  std::string url(argc > 1 ? argv[1] : "https://www.google.com/generate_204");
+  std::string url(argc > 1 ? argv[1] : "https://www.example.com");
   std::cout << "URL: " << url << std::endl;
   SampleExecutor executor;
   PerformRequest(cronet_engine, url, executor.GetExecutor());
diff --git a/components/cronet/native/sample/sample_url_request_callback.cc b/components/cronet/native/sample/sample_url_request_callback.cc
index 396e27dbd27d2..79ddccc0d1ae1 100644
--- a/components/cronet/native/sample/sample_url_request_callback.cc
+++ b/components/cronet/native/sample/sample_url_request_callback.cc
@@ -56,6 +56,7 @@ void SampleUrlRequestCallback::OnReadCompleted(Cronet_UrlRequestPtr request,
   std::string last_read_data(
       reinterpret_cast<char*>(Cronet_Buffer_GetData(buffer)), bytes_read);
   response_as_string_ += last_read_data;
+  std::cout << response_as_string_ << std::endl;
   // Continue reading the response.
   Cronet_UrlRequest_Read(request, buffer);
 }
diff --git a/components/cronet/native/sample/test/sample_test.cc b/components/cronet/native/sample/test/sample_test.cc
index 7831b69f72a4a..8339226d3c9d7 100644
--- a/components/cronet/native/sample/test/sample_test.cc
+++ b/components/cronet/native/sample/test/sample_test.cc
@@ -44,7 +44,12 @@ TEST(SampleTest, TestConnectionRefused) {
   EXPECT_NE(std::string::npos, sample_out.find("net::ERR_INVALID_URL"));
 }
 
-}  // namespace
+// Test that we get an error indicating ohttp is not implemented
+TEST(SampleTest, TestOHTTPDetected) {
+  EXPECT_EQ(0, 1);
+}
+
+}
 
 int main(int argc, char** argv) {
   s_test_app_path = argv[0];
diff --git a/net/BUILD.gn b/net/BUILD.gn
index e12e5b6936b8d..87073ee69a46e 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -1005,6 +1005,8 @@ component("net") {
     "ssl/ssl_server_config.h",
     "ssl/threaded_ssl_private_key.cc",
     "ssl/threaded_ssl_private_key.h",
+    "url_request/ohttp.cc",
+    "url_request/ohttp.h",
     "url_request/redirect_info.cc",
     "url_request/redirect_info.h",
     "url_request/redirect_util.cc",
diff --git a/net/url_request/ohttp.cc b/net/url_request/ohttp.cc
new file mode 100644
index 0000000000000..1df5a4d10654d
--- /dev/null
+++ b/net/url_request/ohttp.cc
@@ -0,0 +1,247 @@
+#include <vector>
+#include <iostream>
+
+#include "net/url_request/ohttp.h"
+#include "third_party/boringssl/src/include/openssl/hpke.h"
+
+namespace net {
+    const char* GetFoo() {
+        return "foo";
+    }
+
+    std::vector<uint8_t> GetDummyHPKEEncapsulatedRequest(){
+        // TODO: HPKE-encapsulate a request via /third_party/boringssl/src/crypto/hpke
+
+        // The byte string
+        // 0 0 48 0 1 0 1 54 90 39 71 100 20 88 215 194 164 140 189 87 62 35 251 160 219 223 17 2 151 132 113 236 217 44 177 100 53 216 91 245 212 71 170 150 133 184 111 28 225 11 109 13 59 24 95 173 3 84 254 137 87 159 199 167 40 80 245 93 115 64 129 52 219 196 170 220 38 120 172 220 188 114 122 214 231 106 206 164 77 51 15 253 5 191 112 104 241 254 121 74 168 175 4 140 56 2 124 37 56 139 2 202 254 87 229 35 9 81 119 115 118 71 80 92 114 194 14 219 249 152 63 241 245 184 74 72 120 234 31 157 84 55 55 225 206 119 225 207 156 82 79 33 112 253 173 225 175 215 24 200 11 248 129 113 57 101 66 116 107 209 40 164 115 108 232 61 228 193 185 34 109 137 103 246 15 114 211 44 245 48 10 71 192 64 111 50 158 121 103 218 147 40 184 137 230 243 247 187 189 98 72 165 231 52 237 166 121 52 221 94 194 206 251 122 95 139 111 123 247 214 86 50 244 115 52 164 67 57 215 133 0 68 32 13 84 133 76 217 226 88 213 25 144 138 83 225 248 46 178 162 255 166 254 217 39 131 250 183 39 242 125 219 0 192 4 10 132 92 43 110 40 110 225 171 243 96 14 215 155 220 49 168 143 208 56 106 175 248 226 194 142 38 205 15 162 156 234 203 171 50 34 75 39 51 73 77 160 54 214 199 94 179 10 234 130 139 182 219 99 25 202 199 218 77 29 10 137 36 78 255 206 37 131 132 251 126 203 60 219 169 217 83 250 78 72 127 214 144 78 118 158 85 242 48 221 9 238 164 22 157 167 48 245 34 196 233 0 156 71 229 20 141 100 143 85 38 106 1 153 245 196 197 29 179 155 192 88 255 222 113 181 122 127 229 69 152 160 237 61 150 93 177 76 162 28 227 106 101 148 184 138 100 68 52 227 243 115 116 92 11 27 1 10 105 60 226 138 61 186 100 97 105 61 75 63 183 203 168 228 46 190 199 104 157 128 128 29 67 19 65 174 164 16 34 220 212 227 212 58 37 44 224 13 102 128 14 178 222 136 215 250 103 186 9 128 172 162 165 82 145 230 131 93 77 232 13 235 241 214 203 33 233 207 79 137 148 53 26 136 25 1 198 145 127 238 107 61 185 124 11 14 22 194 161 33 155 103 105 102 152 191 169 2 158 80 16 124 161 225 0 10 126 78 103 156 70 185 181 117 243 65 0 102 73 42 66 90 162 233 119 202 80 7 121 37 89 182 186 112 163 3 202 160 38 211 84 36 4 37 200 212 185 178 80 173 245 4 205 11 13 59 107 124 153 138 180 189 6 226 222 66 69 213 239 7 201 64 29 141 27 226 124 236 194 117 234 249 198 122 118 12 79 25 51 16 24 133 134 237 237 162 95 205 126 240 202 184 179 117 53 72 58 134 250 252 95 166 59 122 144 8 116 30 207 82 53 242 56 254 179 135 180 236 52 225 31 77 240 61 193 197 62 159 213 22 136 94 132 161 193 149 184 230 163 161 84 112 106 227 99 184 128 145 123 220 136 49 202 73 170 86 167 23 19 12 136 95 218 183 228 237 228 137 160 152 53 111 172 206 109 213 68 141 164 154 230 219 219 190 107 139 65 177 99 211 86 12 223 92 92 88 60 67 45 224 67 141 106 114 28 26 220 10 8 199 57 67 58 198 167 3 151 11 158 157 223 64 35 161 72 255 78 63 159 119 36 142 130 132 81 141 125 76 213 83 133 78 186 237 18 9 216 70 59 23 134 181 129 221 226 203 249 181 82 98 141 119 184 255 146 230 216 190 246 120 149 147 146 240 245 167 243 172 12 135 96 158 191 243 95 60 99 125 82 133 244 132 125 78 71 116 41 248 46 81 226 146 31 251 37 100 37 199 73 202 178 46 56 159 220 185 1 151 128 66 129 237 158 14 100 97 188 168 189 19 232 38 28 117 180 234 148 134 19 220 63 130 153 180 28 229 49 76 176 230 246 163 69 141 87 108 163 126 225 23 104 132 49 72 191 75 20 123 114 20 157 248 200 89 215 178 35 174 81 172 39 194 19 55 231 155 139 10 46 67 89 217 79 58 25 195 167 123 125 23 237 56 91 82 147 9 177 120 14 17 183 76 247 25 146 115 80 21 93 177 3 89 111 227 148 253 11 33 250 202 220 2 189 239 136 29 178 55 246 60 76 142 252 200 16 56 173 131 235 145 67 58 93 13 56 8 108 11 40 37 115 109 81 163 20 101 214 23 182 182 7 105 200 202 54 111 67 174 233 71 205 135 35 7 204 100 111 226 71 138 23 244 81 123 88 150 110 42 193 37 52 133 14 68 15 119 209 138 230 29 41 11 254 42 76 157 71 154 56 159 226 252 211 89 186 203 213 164 234 208 166 67 147 147 228 29 246 151 13 48 31 222 79 19 120 48 165 194 6 218 163 237 99 254 14 179 222 61 43 168 148 62 180 116 10 175 111 215 125 58 201 8 90 78 64 72 105 80 242 138 208 96 242 20 183 29 243 103 5 58 33 215 54 115 205 127 223 24 227 206 189 222 251 16 127 17 181 88 150 183 103 126 219 42 99 233 138 59 150 213 177 6 119 1 62 12 125 83 231 138 97 115 239 93 114 37 234 156 55 218 233 197 217
+        // represents a POST to https://ohttp-gateway.jthess.com with body "foo"
+        // The context used is the HPKE context via toyclient.
+
+        // TODO: Use /home/admin/chromium/src/content/browser/aggregation_service/aggregatable_report_unittest.cc
+        // as a template to design a test for this.
+
+        // Trying a second request... still getting "hpke: invalid KEM identifier"
+        // which, like, who knows what's actually in this thing.
+        std::vector<uint8_t> bytes = {0, 0, 48, 0, 1, 0, 1, 158, 237, 132, 117, 42, 120, 192, 126, 28, 48, 21, 14, 46, 79, 136, 134, 82, 175, 218, 101, 129, 145, 184, 132, 211, 119, 204, 98, 230, 182, 112, 123, 72, 128, 100, 193, 7, 154, 91, 127, 49, 140, 56, 28, 240, 150, 37, 112, 48, 45, 199, 80, 203, 249, 202, 181, 168, 25, 199, 194, 254, 106, 150, 160, 76, 125, 135, 62, 174, 98, 135, 31, 245, 196, 38, 180, 248, 186, 51, 26, 77, 18, 14, 84, 245, 172, 13, 91, 46, 224, 219, 61, 166, 7, 124, 138, 194, 93, 236, 50, 95, 37, 221, 59, 233, 139, 45, 157, 147, 131, 224, 231, 119, 194, 200, 229, 116, 255, 72, 224, 139, 254, 53, 28, 54, 200, 58, 89, 251, 14, 132, 73, 30, 12, 25, 83, 230, 146, 98, 128, 247, 0, 162, 196, 82, 187, 175, 85, 93, 61, 8, 57, 49, 5, 85, 153, 52, 143, 98, 129, 163, 155, 142, 12, 26, 177, 230, 134, 133, 255, 56, 137, 172, 52, 50, 94, 177, 191, 50, 140, 98, 84, 20, 135, 32, 228, 165, 91, 167, 72, 27, 212, 113, 177, 96, 224, 212, 182, 24, 192, 162, 63, 124, 119, 127, 238, 41, 26, 121, 125, 205, 129, 206, 179, 204, 152, 29, 57, 225, 78, 113, 190, 82, 226, 171, 70, 135, 10, 231, 3, 212, 99, 225, 162, 151, 23, 116, 114, 121, 126, 65, 124, 78, 0, 11, 92, 4, 145, 120, 122, 113, 36, 183, 122, 253, 195, 88, 153, 181, 149, 15, 48, 242, 107, 119, 20, 54, 37, 30, 178, 158, 207, 11, 39, 179, 24, 45, 246, 159, 48, 177, 156, 25, 221, 44, 110, 52, 35, 159, 215, 218, 216, 3, 191, 242, 95, 39, 171, 33, 44, 17, 50, 230, 2, 79, 201, 207, 53, 215, 30, 249, 61, 225, 114, 65, 235, 185, 200, 133, 74, 118, 78, 135, 41, 1, 230, 138, 63, 160, 167, 93, 154, 21, 166, 107, 147, 177, 144, 34, 247, 214, 85, 2, 144, 177, 112, 163, 45, 233, 69, 42, 122, 81, 68, 182, 237, 123, 56, 165, 166, 112, 138, 255, 116, 140, 71, 207, 198, 140, 125, 111, 130, 105, 182, 67, 27, 22, 8, 56, 196, 38, 208, 232, 188, 220, 68, 11, 190, 192, 178, 155, 177, 194, 228, 146, 132, 240, 82, 118, 114, 195, 37, 135, 227, 208, 7, 241, 65, 116, 73, 73, 207, 128, 11, 72, 241, 89, 60, 24, 79, 162, 216, 115, 81, 242, 191, 18, 207, 197, 4, 169, 222, 20, 98, 135, 228, 41, 9, 146, 1, 208, 124, 119, 136, 204, 225, 120, 100, 227, 160, 189, 229, 139, 48, 231, 154, 8, 90, 133, 87, 60, 115, 117, 237, 246, 109, 168, 18, 104, 133, 52, 198, 108, 154, 80, 162, 167, 103, 173, 111, 212, 168, 163, 222, 13, 15, 159, 34, 48, 182, 252, 169, 241, 6, 122, 0, 107, 99, 208, 32, 62, 82, 77, 153, 49, 226, 13, 175, 57, 192, 76, 141, 122, 188, 209, 136, 113, 175, 207, 137, 163, 172, 252, 240, 200, 45, 41, 196, 62, 50, 148, 32, 109, 164, 182, 44, 125, 195, 32, 162, 26, 121, 247, 4, 248, 205, 132, 242, 74, 74, 178, 33, 159, 48, 138, 174, 37, 76, 17, 78, 2, 239, 30, 251, 110, 231, 165, 21, 1, 67, 217, 5, 156, 56, 191, 237, 95, 229, 49, 91, 139, 127, 119, 176, 152, 90, 164, 113, 57, 88, 146, 142, 60, 140, 87, 140, 120, 227, 215, 192, 27, 190, 57, 108, 50, 205, 32, 128, 93, 250, 143, 250, 208, 195, 134, 229, 156, 220, 240, 249, 187, 216, 219, 19, 205, 107, 212, 84, 163, 50, 17, 84, 28, 5, 128, 241, 37, 252, 215, 227, 219, 162, 66, 255, 247, 39, 154, 45, 80, 29, 105, 67, 174, 57, 97, 26, 180, 80, 237, 149, 122, 11, 24, 214, 135, 174, 157, 113, 173, 164, 96, 81, 160, 4, 219, 210, 45, 104, 149, 202, 62, 173, 80, 87, 237, 36, 45, 43, 57, 202, 145, 209, 106, 54, 228, 142, 179, 17, 239, 54, 61, 204, 177, 215, 210, 122, 15, 6, 229, 52, 73, 136, 253, 82, 71, 238, 131, 39, 52, 140, 128, 194, 206, 111, 196, 13, 54, 172, 140, 176, 24, 97, 23, 61, 12, 163, 200, 176, 129, 40, 185, 126, 76, 244, 192, 230, 56, 83, 187, 46, 134, 83, 239, 70, 78, 215, 39, 9, 82, 78, 7, 103, 11, 134, 118, 225, 137, 40, 14, 101, 246, 31, 235, 94, 7, 214, 180, 217, 71, 92, 245, 99, 76, 92, 250, 33, 40, 84, 109, 251, 131, 32, 151, 120, 198, 245, 244, 204, 145, 61, 240, 197, 235, 174, 191, 169, 27, 216, 120, 44, 114, 83, 120, 75, 45, 195, 150, 132, 10, 46, 2, 167, 21, 165, 39, 163, 98, 124, 215, 228, 109, 192, 65, 30, 127, 221, 129, 114, 204, 120, 208, 243, 14, 208, 185, 217, 112, 187, 72, 175, 34, 142, 90, 187, 176, 129, 174, 85, 135, 43, 144, 225, 220, 29, 24, 177, 238, 40, 29, 220, 140, 3, 35, 73, 110, 243, 14, 122, 233, 93, 65, 161, 39, 250, 51, 116, 44, 138, 187, 241, 51, 118, 85, 74, 171, 54, 76, 254, 194, 193, 192, 89, 32, 18, 23, 4, 18, 176, 245, 255, 163, 191, 199, 182, 119, 169, 69, 112, 122, 49, 207, 202, 99, 19, 17, 68, 44, 237, 240, 189, 19, 137, 172, 152, 181, 165, 50, 170, 222, 154, 2, 140, 172, 42, 63, 49, 7, 72, 45, 77, 228, 197, 63, 150, 77, 28, 250, 243, 81, 96, 236, 23, 83, 206, 245, 38, 62, 102, 242, 227, 4, 140, 59, 206, 236, 170, 238, 229, 54, 107, 228, 186, 81, 210, 179, 220, 77, 73, 171, 8, 227, 162, 239, 242, 141, 58, 215, 194, 254, 33, 8, 148, 26, 203, 124, 10, 56, 239, 18, 232, 4, 49, 233, 40, 50, 14, 248, 43, 216, 244, 189, 154, 127, 215, 142, 248, 141, 117, 23, 254, 225, 134, 219, 67, 201, 204, 111, 197, 37, 93, 194, 142, 35, 12, 40, 162, 24, 23, 80, 127, 126, 46, 106, 50, 210, 133, 227, 50, 128, 228, 241, 249, 187, 208, 211, 229, 42, 179, 91, 197, 74, 143, 9, 45, 205, 185, 111, 252, 210, 146, 0, 128, 70, 204, 13, 89, 136, 173, 101, 17, 175, 52, 190, 179, 115, 25, 9, 13, 210, 0, 113, 85, 135, 19, 210, 221, 220, 105, 153, 91, 4, 39, 125, 11, 20, 17, 245, 111, 224, 192, 181, 121, 237, 95, 232, 72, 94, 19, 6, 39, 7, 29, 82, 98, 152, 214, 237, 235, 108, 24, 134, 10, 61, 210, 67, 31, 203, 109, 57, 251, 121, 97, 240, 247, 32, 234, 103, 21, 39, 228, 238, 86, 58, 197, 238, 84, 109, 17, 115, 177, 104, 122, 96, 232, 90, 21, 26, 42, 214, 169, 119};
+        return bytes;
+    }
+
+    // Helper to encode a string as a binary vector (length-prefixed)
+    std::vector<uint8_t> encode_string(const std::string& str) {
+        std::vector<uint8_t> result;
+
+        // WARNING: Cloudflare/Wood implementation uses just one byte
+        // where we would expect to see 2 per RFC 9292.
+
+        uint16_t length = str.size();
+        result.push_back((length >> 8) & 0xFF); // length high byte
+        result.push_back(length & 0xFF);        // length low byte
+        result.insert(result.end(), str.begin(), str.end());
+        return result;
+    }
+
+    // Function to encode the POST request in binary format per RFC 9292
+    std::vector<uint8_t> get_binary_request(const std::string& path, const std::string& host, const std::string& body) {
+        std::vector<uint8_t> binary_request;
+
+        // Known-Length Request {
+        //   Framing Indicator (i) = 0,
+        //   Request Control Data (..),
+        //   Known-Length Field Section (..),
+        //   Known-Length Content (..),
+        //   Known-Length Field Section (..),
+        //   Padding (..),
+        // }
+
+        // Framing indicator.  0 for fixed length request.
+        std::vector<uint8_t> framing_indicator = {0};
+        binary_request.insert(binary_request.end(), framing_indicator.begin(), framing_indicator.end());
+
+        // Control Data
+        // Request Control Data {
+        //   Method Length (i),
+        //   Method (..),
+        //   Scheme Length (i),
+        //   Scheme (..),
+        //   Authority Length (i),
+        //   Authority (..),
+        //   Path Length (i),
+        //   Path (..),
+        // }
+
+        // Method Length & Method
+        std::string method_value = "POST";
+        std::vector<uint8_t> method_value_field = encode_string(method_value);
+        // std::cout << "Method value field size: " << method_value_field.size() << std::endl;
+        // std::cout << "Method value field: ";
+        // for (uint8_t byte : method_value_field) {
+        //     std::cout << (int)byte << " ";
+        // }
+        binary_request.insert(binary_request.end(), method_value_field.begin(), method_value_field.end());
+
+        // Scheme Length & Scheme
+        std::string scheme_value = "https";
+        std::vector<uint8_t> scheme_value_field = encode_string(scheme_value);
+        binary_request.insert(binary_request.end(), scheme_value_field.begin(), scheme_value_field.end());
+        
+        // Authority Length & Authority
+        std::string authority_value = host;
+        std::vector<uint8_t> authority_value_field = encode_string(authority_value);
+        binary_request.insert(binary_request.end(), authority_value_field.begin(), authority_value_field.end());
+
+        // Path Length & Path
+        std::vector<uint8_t> path_value_field = encode_string(path);
+        binary_request.insert(binary_request.end(), path_value_field.begin(), path_value_field.end());
+
+        // Header section.
+        // Known-Length Field Section {
+        //   Length (i),
+        //   Field Line (..) ...,
+        // }
+
+        // Length & Field Line
+        std::vector<uint8_t> no_fields = encode_string("");
+        binary_request.insert(binary_request.end(), no_fields.begin(), no_fields.end());
+
+        // Known-Length Content {
+        //   Content Length (i),
+        //   Content (..),
+        // }
+
+        // Content Length & Content
+        std::vector<uint8_t> body_field = encode_string(body);
+        binary_request.insert(binary_request.end(), body_field.begin(), body_field.end());
+
+        // Trailer section
+        // Known-Length Field Section {
+        //   Length (i),
+        //   Field Line (..) ...,
+        // }
+
+        // WARNING: Another deviation from cloudflare implementation
+
+        // Length & Field Line
+        binary_request.insert(binary_request.end(), no_fields.begin(), no_fields.end());
+
+        // No zero bytes.
+        return binary_request;
+    }
+
+    std::vector<uint8_t> get_encapsulated_request() {
+        // Hard coded key config matching ohttp-gateway.jthess.com's
+        // public key.
+
+        // Key ID (8 bit)                 80
+        // HPKE KEM ID (16)               0020 
+        // HPKE Public Key (8*Npk=8*32)   ea0060b17d5c7216e6f7d22ba14e337e6602b96d3435b6445b09180880edf81d
+        // HPKE Symmetric Algos Len (16)  0004
+        // HPKE Symmetric algorithms (32) 
+        //   HPKE KDF ID                  0001
+        //   HPKE AEAD ID                 0001
+        std::vector<uint8_t> binary_request = get_binary_request("/", "ohttp-gateway.jthess.com", "foo");
+        std::vector<uint8_t> encapsulated_request;
+
+        // Create a context
+        bssl::ScopedEVP_HPKE_CTX sender_context;
+        std::cout << "Setting enc len to " << X25519_PUBLIC_VALUE_LEN << std::endl;
+        uint8_t enc[X25519_PUBLIC_VALUE_LEN];
+        size_t enc_len;
+
+        uint8_t pkR[X25519_PUBLIC_VALUE_LEN] = {
+            0xea, 0x00, 0x60, 0xb1, 0x7d, 0x5c, 0x72, 0x16,
+            0xe6, 0xf7, 0xd2, 0x2b, 0xa1, 0x4e, 0x33, 0x7e,
+            0x66, 0x02, 0xb9, 0x6d, 0x34, 0x35, 0xb6, 0x44,
+            0x5b, 0x09, 0x18, 0x08, 0x80, 0xed, 0xf8, 0x1d
+        };
+        size_t Npk = 32;
+
+        // Build a sequence of bytes (info) by concatenating the ASCII-encoded 
+        // string "message/bhttp request", a zero byte.
+        std::vector<uint8_t> info_message = encode_string("message/bhttp request");
+        std::vector<uint8_t> info;
+        info.insert(info.end(), info_message.begin(), info_message.end());
+        info.push_back(0x00);  // Zero Byte
+
+        // TODO Catch errors.
+        int rv;
+        rv = EVP_HPKE_CTX_setup_sender(
+            /* *ctx */ sender_context.get(),
+            /* *out_enc */ enc, // Shared secret
+            /* *out_enc_len */ &enc_len,
+            /*  max_enc */ sizeof(enc),
+            /* *kem */ EVP_hpke_x25519_hkdf_sha256(),  // We want 0x0020, DHKEM(X25519, HKDF-SHA256);	see: https://www.iana.org/assignments/hpke/hpke.xhtml
+            /* *kdf */ EVP_hpke_hkdf_sha256(),  // 0x0001, HKDF-SHA256
+            /* *aead */ EVP_hpke_aes_128_gcm(),  // 0x0001, AES-128-GCM
+            /* *peer_public_key */ pkR,
+            /*  peer_public_key_len */ Npk,
+            /* *info */ info.data(),
+            /*  info_len */ info.size()
+        );
+        if (rv != 1) {
+            std::cout << "Error setting up sender context." << std::endl;
+            return {};
+        }
+
+        // Have sender encrypt message for the recipient.
+        int ct_max_len = binary_request.size() +
+            EVP_HPKE_CTX_max_overhead(sender_context.get());
+        std::cout << "ct_max_len: " << ct_max_len << std::endl;
+        std::vector<uint8_t> ciphertext(ct_max_len);
+        size_t ciphertext_len;
+        std::vector<uint8_t> aad = {
+            0x80, // Key ID
+            0x00, 0x20, // HPKE KEM ID
+            0x00, 0x01, // KDF ID
+            0x00, 0x01, // AEAD ID
+        };
+        rv = EVP_HPKE_CTX_seal(
+            /* *ctx */ sender_context.get(),
+            /* *out */ ciphertext.data(),
+            /* *out_len */ &ciphertext_len,
+            /*  max_out_len */ ciphertext.size(),
+            /* *in */ binary_request.data(),
+            /*  in_len */ binary_request.size(),
+            /* *ad */ aad.data(),
+            /*  ad_len */ aad.size()
+        );
+        if (rv != 1) {
+            std::cout << "Error sealing message." << std::endl;
+            return {};
+        }
+        std::cout << "pt length: " << binary_request.size() << std::endl;
+        std::cout << "aad length: " << aad.size() << std::endl;
+        std::cout << "enc length: " << enc_len << std::endl;
+        std::cout << "ct length: " << ciphertext_len << std::endl;
+
+        std::cout << "Plaintext: " << std::endl;
+        for (uint8_t byte : binary_request) {
+            std::cout << (int)byte << " ";
+        }
+        std::cout << std::endl;
+        std::cout << "aad: " << std::endl;
+        for (uint8_t byte : aad) {
+            std::cout << (int)byte << " ";
+        }
+        std::cout << std::endl;
+        std::cout << "enc: " << std::endl;
+        for (uint8_t byte : enc) {
+            std::cout << (int)byte << " ";
+        }
+        std::cout << std::endl;
+        std::cout << "ct: " << std::endl;
+        for (uint8_t byte : ciphertext) {
+            std::cout << (int)byte << " ";
+        }
+        std::cout << std::endl;
+
+        // Per RFC 9292, the encapsulated request is the concatenation of the
+        // aad, enc, and ciphertext.
+        encapsulated_request.insert(encapsulated_request.end(), aad.begin(), aad.end());
+        encapsulated_request.insert(encapsulated_request.end(), enc, enc + enc_len);
+        encapsulated_request.insert(encapsulated_request.end(), ciphertext.begin(), ciphertext.begin() + ciphertext_len);
+        std::cout << "encap length: " << encapsulated_request.size() << std::endl;
+
+        return encapsulated_request;
+    }
+
+}
\ No newline at end of file
diff --git a/net/url_request/ohttp.h b/net/url_request/ohttp.h
new file mode 100644
index 0000000000000..9eec11759da0a
--- /dev/null
+++ b/net/url_request/ohttp.h
@@ -0,0 +1,24 @@
+// Sketch of OHTTP implementation
+
+#ifndef NET_URL_REQUEST_OHTTP_H_
+#define NET_URL_REQUEST_OHTTP_H_
+
+#include <string>
+#include <vector>
+
+namespace net {
+
+    // A function that simply returns the string "foo"
+    const char* GetFoo();
+
+    std::vector<uint8_t> GetDummyHPKEEncapsulatedRequest();
+
+    std::vector<uint8_t> encode_string(const std::string& str);
+
+    std::vector<uint8_t> get_binary_request(const std::string& path, const std::string& host, const std::string& body);
+    
+    std::vector<uint8_t> get_encapsulated_request();
+
+} // namespace net
+
+#endif  // NET_URL_REQUEST_OHTTP_H_
\ No newline at end of file
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index b3b5b9da8f5ae..946fe87bcd910 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -51,6 +51,7 @@
 #include "net/socket/network_binding_client_socket_factory.h"
 #include "net/ssl/ssl_cipher_suite_names.h"
 #include "net/ssl/ssl_config_service_defaults.h"
+#include "net/url_request/ohttp.h"
 #include "net/url_request/static_http_user_agent_settings.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
@@ -286,8 +287,12 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   context->set_require_network_isolation_key(require_network_isolation_key_);
   context->set_network_quality_estimator(network_quality_estimator_);
 
-  if (!envoy_url_.empty())
+  // Give the context the Envoy URL
+  if (!envoy_url_.empty()) {
     context->set_envoy_url(envoy_url_);
+    std::cout << "Envoy URL is: " << envoy_url_ << std::endl;
+    std::cout << "Our Request is: " << net::GetFoo() << std::endl;
+  }
   if (http_user_agent_settings_) {
     context->set_http_user_agent_settings(std::move(http_user_agent_settings_));
   } else {
@@ -380,6 +385,7 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   // TODO assert value
   auto url = GURL(value);
 
+  // Set resolve/address/MAP, if specified.
   if (GetValueForKeyInQuery(envoy_url, "resolve", &value)) {
     std::unique_ptr<net::MappedHostResolver> remapped_resolver(
         new net::MappedHostResolver(std::move(host_resolver_)));
@@ -399,6 +405,7 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   } else {
     SSLContextConfig ssl_context_config;
     std::vector<uint16_t> disabled_ciphers;
+    // Disable cipher suites, if specified
     if (GetValueForKeyInQuery(envoy_url, "disabled_cipher_suites", &value)) {
       auto cipher_strings = base::SplitString(value, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
       // see net::ParseCipherSuites(cipher_strings);
diff --git a/net/url_request/url_request_http_job.cc b/net/url_request/url_request_http_job.cc
index da6ee48808da0..df4f200fa6d20 100644
--- a/net/url_request/url_request_http_job.cc
+++ b/net/url_request/url_request_http_job.cc
@@ -36,6 +36,7 @@
 #include "base/values.h"
 #include "build/build_config.h"
 #include "base/strings/escape.h"
+#include "net/base/elements_upload_data_stream.h"
 #include "net/base/features.h"
 #include "net/base/host_port_pair.h"
 #include "net/base/http_user_agent_settings.h"
@@ -47,6 +48,7 @@
 #include "net/base/privacy_mode.h"
 #include "net/base/registry_controlled_domains/registry_controlled_domain.h"
 #include "net/base/trace_constants.h"
+#include "net/base/upload_bytes_element_reader.h"
 #include "net/base/url_util.h"
 #include "net/cert/cert_status_flags.h"
 #include "net/cert/ct_policy_status.h"
@@ -85,6 +87,7 @@
 #include "net/ssl/ssl_cert_request_info.h"
 #include "net/ssl/ssl_config_service.h"
 #include "net/ssl/ssl_connection_status_flags.h"
+#include "net/url_request/ohttp.h"
 #include "net/url_request/redirect_util.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_context.h"
@@ -538,6 +541,7 @@ void URLRequestHttpJob::MaybeStartTransactionInternal(int result) {
 
 void URLRequestHttpJob::StartTransactionInternal() {
   DCHECK(!override_response_headers_);
+  std::cout << "Trying to hit: " << request_info_.url << std::endl;
 
   // NOTE: This method assumes that request_info_ is already setup properly.
 
@@ -560,6 +564,25 @@ void URLRequestHttpJob::StartTransactionInternal() {
   } else {
     DCHECK(request_->context()->http_transaction_factory());
 
+    // refactor this with the same conditional below
+    if (!(request_info_.load_flags & LOAD_BYPASS_PROXY)) {
+      if (request_->context()->envoy_url().rfind("http://", 0) == 0 ||
+                    request_->context()->envoy_url().rfind("https://", 0) == 0 ||
+                    request_->context()->envoy_url().rfind("envoy://", 0) == 0) {
+        // Override the response since we need to decrypt it
+        std::cout << "Constructing an HPKE encapsulated binary request" << std::endl;
+        byte_data = net::get_encapsulated_request();
+        const char* request_data = reinterpret_cast<const char*>(byte_data.data());
+        std::vector<std::unique_ptr<UploadElementReader>> readers;
+        readers.push_back(
+          std::make_unique<net::UploadBytesElementReader>(request_data, byte_data.size()));
+        std::unique_ptr<UploadDataStream> upload_stream =
+          std::make_unique<ElementsUploadDataStream>(std::move(readers), 0);
+        SetUpload(upload_stream.release());
+      }
+    }
+
+    // This sets transaction_, so the upload must be changed before this point
     rv = request_->context()->http_transaction_factory()->CreateTransaction(
         priority_, &transaction_);
 
@@ -575,6 +598,7 @@ void URLRequestHttpJob::StartTransactionInternal() {
     }
 
     if (rv == OK) {
+
       transaction_->SetConnectedCallback(base::BindRepeating(
           &URLRequestHttpJob::NotifyConnectedCallback, base::Unretained(this)));
       transaction_->SetRequestHeadersCallback(request_headers_callback_);
@@ -587,6 +611,9 @@ void URLRequestHttpJob::StartTransactionInternal() {
 
         // Don't use the Envoy proxy when LOAD_BYPASS_PROXY is set
         // Specifically, we don't want to use Envoy for DoH requests
+        // Why don't we use it for DoH?
+        // How does Envoy allow proxying only some requests?
+        // This section actually routes our request through the proxy.
         if (!(request_info_.load_flags & LOAD_BYPASS_PROXY)) {
 
           if (request_->context()->envoy_url().rfind("http://", 0) == 0 ||
@@ -607,20 +634,30 @@ void URLRequestHttpJob::StartTransactionInternal() {
                 auto value = it.GetUnescapedValue();
                 if (key.compare("url") == 0) {
                   // see GetUnescapedValue, TODO check is_valid() before set
-                  request_info_.url =
-                      GURL(base::UnescapeURLComponent(value, base::UnescapeRule::NORMAL));
-              } else if (key.compare("salt") == 0) {
-                      salt = value;
+                  request_info_.url = GURL(base::UnescapeURLComponent(
+                      value, base::UnescapeRule::NORMAL));
+                } else if (key.compare("salt") == 0) {
+                  salt = value;
                 } else if (key.rfind(headerPrefix, 0) == 0 &&
-                          key.size() > headerPrefixLength) {
+                           key.size() > headerPrefixLength) {
+                  request_info_.extra_headers.SetHeader(
+                      key.substr(headerPrefixLength),
+                      value);  // check for header Host, add :authority for
+                               // http2; :path for http2
+                } else if (key.compare("ohttp") == 0) {
+                  // Do OHTTP Things
+                  // TODO: HPKE-encapsulated version of original request.
+                  request_info_.method = "POST";
                   request_info_.extra_headers.SetHeader(
-                      key.substr(headerPrefixLength), value); // check for header Host, add :authority for http2; :path for http2
+                    "Content-Type", "message/ohttp-req");
                 }
               }
             }
 
 
             // count for cache key
+            // So why do we use the digest?  It gets passed to the proxy, but not to the
+            // target server (that's good).
             auto digest = crypto::SHA256HashString(request_->url().spec() + salt);
             request_info_.url =
                 AppendQueryParameter(request_info_.url, "_digest", digest);
diff --git a/net/url_request/url_request_http_job.h b/net/url_request/url_request_http_job.h
index 866c8287a9b95..fd26d87b87e2a 100644
--- a/net/url_request/url_request_http_job.h
+++ b/net/url_request/url_request_http_job.h
@@ -60,7 +60,7 @@ class NET_EXPORT_PRIVATE URLRequestHttpJob : public URLRequestJob {
   void SetEarlyResponseHeadersCallback(
       ResponseHeadersCallback callback) override;
   void SetResponseHeadersCallback(ResponseHeadersCallback callback) override;
-
+  std::vector<uint8_t> byte_data;
  protected:
   URLRequestHttpJob(URLRequest* request,
                     const HttpUserAgentSettings* http_user_agent_settings);
