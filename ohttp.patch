diff --git a/components/cronet/BUILD.gn b/components/cronet/BUILD.gn
index 92350cf3b4b77..cf15c3fda0faf 100644
--- a/components/cronet/BUILD.gn
+++ b/components/cronet/BUILD.gn
@@ -275,6 +275,8 @@ if (is_android) {
     deps = [
       "//components/cronet",
       "//components/cronet/native:cronet_native_headers",
+      "//third_party/boringssl",
+      "//third_party/ohttp",
     ]
     if ((is_linux || is_chromeos) && !is_component_build) {
       public_configs = [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
diff --git a/components/cronet/native/sample/main.cc b/components/cronet/native/sample/main.cc
index 007d5bbab90d7..64e0b7453ec6d 100644
--- a/components/cronet/native/sample/main.cc
+++ b/components/cronet/native/sample/main.cc
@@ -3,55 +3,32 @@
 // found in the LICENSE file.
 
 #include <iostream>
+#include <vector>
+#include <string>
+#include <cstdint>
 
 #include "cronet_c.h"
+#include "openssl/evp.h"
 #include "sample_executor.h"
 #include "sample_url_request_callback.h"
+#include "third_party/boringssl/src/include/openssl/hpke.h"
+#include "third_party/ohttp/ohttp.h"
 
-Cronet_EnginePtr CreateCronetEngine() {
-  Cronet_EnginePtr cronet_engine = Cronet_Engine_Create();
-  Cronet_EngineParamsPtr engine_params = Cronet_EngineParams_Create();
-  Cronet_EngineParams_user_agent_set(engine_params, "CronetSample/1");
 
-  Cronet_EngineParams_envoy_url_set(engine_params,
-                                    "https://example.com/enovy_path/");
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&resolve=MAP%20example.com%201.2.3.4");
-  // only MAP url-host to address
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&address=1.2.3.4");
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&address=1.2.3.4&disabled_cipher_suites=0xc024,0xc02f");
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&address=1.2.3.4&disabled_cipher_suites=0xc024,0xc02f");
-  Cronet_EngineParams_envoy_url_set(engine_params, "socks5://127.0.0.1:1080");
-  // proxy URL and SOCKS5 together (for true PTs)
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Frayon.example.com%2Fwikipedia%2F&address=142.65.13.41"
-      "&header_Host=abc.example.com&socks5=socks5%3A%2F%2Flocalhost%3A8192");
- 
-  Cronet_EngineParams_enable_quic_set(engine_params, true);
 
-  Cronet_Engine_StartWithParams(cronet_engine, engine_params);
-  Cronet_EngineParams_Destroy(engine_params);
-  return cronet_engine;
+// Function to base64 encode
+std::string base64_encode(const std::string& input) {
+    size_t output_length = 4 * ((input.size() + 2) / 3);
+    std::string encoded(output_length, '\0');
+    
+    int actual_length = EVP_EncodeBlock(reinterpret_cast<unsigned char*>(&encoded[0]),
+                                        reinterpret_cast<const unsigned char*>(input.data()),
+                                        input.size());
+    encoded.resize(actual_length);  // Trim to actual length
+    return encoded;
 }
 
-void PerformRequest(Cronet_EnginePtr cronet_engine,
+std::string GetResponseBody(Cronet_EnginePtr cronet_engine,
                     const std::string& url,
                     Cronet_ExecutorPtr executor) {
   SampleUrlRequestCallback url_request_callback;
@@ -68,8 +45,42 @@ void PerformRequest(Cronet_EnginePtr cronet_engine,
   url_request_callback.WaitForDone();
   Cronet_UrlRequest_Destroy(request);
 
-  std::cout << "Response Data:" << std::endl
-            << url_request_callback.response_as_string() << std::endl;
+  return url_request_callback.response_as_string();
+}
+
+Cronet_EnginePtr CreateCronetEngine() {
+  Cronet_EnginePtr cronet_engine = Cronet_Engine_Create();
+  Cronet_EngineParamsPtr engine_params = Cronet_EngineParams_Create();
+  Cronet_EngineParams_user_agent_set(engine_params, "CronetSample/1");
+
+  // Get the OHTTP config for use in our envoy URL.
+  Cronet_Engine_StartWithParams(cronet_engine, engine_params);
+  SampleExecutor executor;
+  std::string config = GetResponseBody(cronet_engine, "https://ohttp-gateway.jthess.com/gog/ohttp-keys", executor.GetExecutor());
+  std::string config_as_base64 = base64_encode(config);
+  Cronet_Engine_Shutdown(cronet_engine);
+
+  std::string envoy_url = "envoy://"
+      "?url=https%3A%2F%2Fohttp-relay.jthess.com" // Relay
+      "&ohttp=1" // Flag to indicate this is an ohttp relay
+      "&ohttp_gateway=ohttp-gateway.jthess.com/gog/gateway"
+      "&ohttp_config=";
+  
+  envoy_url = envoy_url + config_as_base64;
+  Cronet_EngineParams_envoy_url_set(engine_params, envoy_url.c_str());  
+  Cronet_EngineParams_enable_quic_set(engine_params, true);
+
+  Cronet_Engine_StartWithParams(cronet_engine, engine_params);
+  Cronet_EngineParams_Destroy(engine_params);
+  // Use that engine to get the OHTTP config.
+  return cronet_engine;
+}
+
+void PerformRequest(Cronet_EnginePtr cronet_engine,
+                    const std::string& url,
+                    Cronet_ExecutorPtr executor) {
+  std::string response = GetResponseBody(cronet_engine, url, executor);
+  std::cout << "Response to caller: " << std::endl << std::endl << response << std::endl;
 }
 
 // Download a resource from the Internet. Optional argument must specify
@@ -77,11 +88,11 @@ void PerformRequest(Cronet_EnginePtr cronet_engine,
 int main(int argc, const char* argv[]) {
   std::cout << "Hello from Cronet!\n";
   Cronet_EnginePtr cronet_engine = CreateCronetEngine();
-  std::cout << "Cronet version: "
+  std::cout << "  Cronet version: "
             << Cronet_Engine_GetVersionString(cronet_engine) << std::endl;
 
-  std::string url(argc > 1 ? argv[1] : "https://www.google.com/generate_204");
-  std::cout << "URL: " << url << std::endl;
+  std::string url(argc > 1 ? argv[1] : "https://www.example.com");
+  std::cout << "  GETting URL: " << url << " via OHTTP" << std::endl;
   SampleExecutor executor;
   PerformRequest(cronet_engine, url, executor.GetExecutor());
 
diff --git a/components/cronet/native/sample/sample_url_request_callback.cc b/components/cronet/native/sample/sample_url_request_callback.cc
index 396e27dbd27d2..6e3ca7f3752ca 100644
--- a/components/cronet/native/sample/sample_url_request_callback.cc
+++ b/components/cronet/native/sample/sample_url_request_callback.cc
@@ -29,17 +29,17 @@ void SampleUrlRequestCallback::OnRedirectReceived(
     Cronet_UrlRequestPtr request,
     Cronet_UrlResponseInfoPtr info,
     Cronet_String newLocationUrl) {
-  std::cout << "OnRedirectReceived called: " << newLocationUrl << std::endl;
+  // std::cout << "SampleUrlRequestCallback::OnRedirectReceived called: " << newLocationUrl << std::endl;
   Cronet_UrlRequest_FollowRedirect(request);
 }
 
 void SampleUrlRequestCallback::OnResponseStarted(
     Cronet_UrlRequestPtr request,
     Cronet_UrlResponseInfoPtr info) {
-  std::cout << "OnResponseStarted called." << std::endl;
-  std::cout << "HTTP Status: "
-            << Cronet_UrlResponseInfo_http_status_code_get(info) << " "
-            << Cronet_UrlResponseInfo_http_status_text_get(info) << std::endl;
+  // std::cout << "SampleUrlRequestCallback::OnResponseStarted called." << std::endl;
+  // std::cout << "HTTP Status to Caller: " << std::dec
+            // << Cronet_UrlResponseInfo_http_status_code_get(info) << " "
+            // << Cronet_UrlResponseInfo_http_status_text_get(info) << std::endl;
   // Create and allocate 32kb buffer.
   Cronet_BufferPtr buffer = Cronet_Buffer_Create();
   Cronet_Buffer_InitWithAlloc(buffer, 32 * 1024);
@@ -51,8 +51,10 @@ void SampleUrlRequestCallback::OnReadCompleted(Cronet_UrlRequestPtr request,
                                                Cronet_UrlResponseInfoPtr info,
                                                Cronet_BufferPtr buffer,
                                                uint64_t bytes_read) {
-  std::cout << "OnReadCompleted called: " << bytes_read << " bytes read."
-            << std::endl;
+  // std::cout << "SampleUrlRequestCallback::OnReadCompleted called: " << bytes_read << " bytes read."
+            // << std::endl;
+  // It's possible that the data's not ready yet so it hasn't been decapsulated.
+  // If that's true, we need to deal with that.
   std::string last_read_data(
       reinterpret_cast<char*>(Cronet_Buffer_GetData(buffer)), bytes_read);
   response_as_string_ += last_read_data;
@@ -62,22 +64,22 @@ void SampleUrlRequestCallback::OnReadCompleted(Cronet_UrlRequestPtr request,
 
 void SampleUrlRequestCallback::OnSucceeded(Cronet_UrlRequestPtr request,
                                            Cronet_UrlResponseInfoPtr info) {
-  std::cout << "OnSucceeded called." << std::endl;
+  // std::cout << "SampleUrlRequestCallback::OnSucceeded called." << std::endl;
   SignalDone(true);
 }
 
 void SampleUrlRequestCallback::OnFailed(Cronet_UrlRequestPtr request,
                                         Cronet_UrlResponseInfoPtr info,
                                         Cronet_ErrorPtr error) {
-  std::cout << "OnFailed called: " << Cronet_Error_message_get(error)
-            << std::endl;
+  // std::cout << "SampleUrlRequestCallback::OnFailed called: " << Cronet_Error_message_get(error)
+            // << std::endl;
   last_error_message_ = Cronet_Error_message_get(error);
   SignalDone(false);
 }
 
 void SampleUrlRequestCallback::OnCanceled(Cronet_UrlRequestPtr request,
                                           Cronet_UrlResponseInfoPtr info) {
-  std::cout << "OnCanceled called." << std::endl;
+  // std::cout << "OnCanceled called." << std::endl;
   SignalDone(false);
 }
 
diff --git a/components/cronet/native/sample/test/sample_test.cc b/components/cronet/native/sample/test/sample_test.cc
index 7831b69f72a4a..ee0e6167ada44 100644
--- a/components/cronet/native/sample/test/sample_test.cc
+++ b/components/cronet/native/sample/test/sample_test.cc
@@ -44,7 +44,7 @@ TEST(SampleTest, TestConnectionRefused) {
   EXPECT_NE(std::string::npos, sample_out.find("net::ERR_INVALID_URL"));
 }
 
-}  // namespace
+}
 
 int main(int argc, char** argv) {
   s_test_app_path = argv[0];
diff --git a/net/BUILD.gn b/net/BUILD.gn
index e12e5b6936b8d..bbd05f79d0072 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -1078,6 +1078,7 @@ component("net") {
     "//net/dns:mdns_client",
     "//net/dns/public",
     "//net/third_party/quiche",
+    "//third_party/ohttp",
   ]
 
   allow_circular_includes_from = [
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index b3b5b9da8f5ae..552acc549a6f4 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -55,6 +55,7 @@
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
 #include "net/url_request/url_request_throttler_manager.h"
+#include "third_party/ohttp/ohttp.h"
 #include "url/url_constants.h"
 
 #if BUILDFLAG(ENABLE_REPORTING)
@@ -286,8 +287,10 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   context->set_require_network_isolation_key(require_network_isolation_key_);
   context->set_network_quality_estimator(network_quality_estimator_);
 
-  if (!envoy_url_.empty())
+  // Give the context the Envoy URL
+  if (!envoy_url_.empty()) {
     context->set_envoy_url(envoy_url_);
+  }
   if (http_user_agent_settings_) {
     context->set_http_user_agent_settings(std::move(http_user_agent_settings_));
   } else {
@@ -380,6 +383,7 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   // TODO assert value
   auto url = GURL(value);
 
+  // Set resolve/address/MAP, if specified.
   if (GetValueForKeyInQuery(envoy_url, "resolve", &value)) {
     std::unique_ptr<net::MappedHostResolver> remapped_resolver(
         new net::MappedHostResolver(std::move(host_resolver_)));
@@ -399,6 +403,7 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   } else {
     SSLContextConfig ssl_context_config;
     std::vector<uint16_t> disabled_ciphers;
+    // Disable cipher suites, if specified
     if (GetValueForKeyInQuery(envoy_url, "disabled_cipher_suites", &value)) {
       auto cipher_strings = base::SplitString(value, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
       // see net::ParseCipherSuites(cipher_strings);
diff --git a/net/url_request/url_request_http_job.cc b/net/url_request/url_request_http_job.cc
index da6ee48808da0..f3816c2146bc3 100644
--- a/net/url_request/url_request_http_job.cc
+++ b/net/url_request/url_request_http_job.cc
@@ -36,6 +36,7 @@
 #include "base/values.h"
 #include "build/build_config.h"
 #include "base/strings/escape.h"
+#include "net/base/elements_upload_data_stream.h"
 #include "net/base/features.h"
 #include "net/base/host_port_pair.h"
 #include "net/base/http_user_agent_settings.h"
@@ -47,6 +48,7 @@
 #include "net/base/privacy_mode.h"
 #include "net/base/registry_controlled_domains/registry_controlled_domain.h"
 #include "net/base/trace_constants.h"
+#include "net/base/upload_bytes_element_reader.h"
 #include "net/base/url_util.h"
 #include "net/cert/cert_status_flags.h"
 #include "net/cert/ct_policy_status.h"
@@ -93,7 +95,9 @@
 #include "net/url_request/url_request_redirect_job.h"
 #include "net/url_request/url_request_throttler_manager.h"
 #include "net/url_request/websocket_handshake_userdata_key.h"
+#include "openssl/evp.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/ohttp/ohttp.h"
 #include "url/gurl.h"
 #include "url/origin.h"
 #include "url/url_constants.h"
@@ -189,6 +193,16 @@ GURL UpgradeSchemeToCryptographic(const GURL& insecure_url) {
   return secure_url;
 }
 
+// For parsing b64 OHTTP config in Envoy URL
+std::vector<uint8_t> base64_decode(const std::string& input) {
+    uint8_t* output = new uint8_t[input.size()];
+    int actual_length = EVP_DecodeBlock(output,
+                                        reinterpret_cast<const unsigned char*>(input.data()),
+                                        input.size());
+    std::vector<uint8_t> decoded(output, output + actual_length);
+    return decoded;
+}
+
 }  // namespace
 
 namespace net {
@@ -538,7 +552,6 @@ void URLRequestHttpJob::MaybeStartTransactionInternal(int result) {
 
 void URLRequestHttpJob::StartTransactionInternal() {
   DCHECK(!override_response_headers_);
-
   // NOTE: This method assumes that request_info_ is already setup properly.
 
   // If we already have a transaction, then we should restart the transaction
@@ -560,6 +573,48 @@ void URLRequestHttpJob::StartTransactionInternal() {
   } else {
     DCHECK(request_->context()->http_transaction_factory());
 
+    // refactor this with the same conditional below
+    if (!(request_info_.load_flags & LOAD_BYPASS_PROXY)) {
+      if (request_->context()->envoy_url().rfind("http://", 0) == 0 ||
+                    request_->context()->envoy_url().rfind("https://", 0) == 0 ||
+                    request_->context()->envoy_url().rfind("envoy://", 0) == 0) {
+        size_t pkR_len = 32;
+        // Get the OHTTP Config from the Envoy URL
+        size_t ohttp_config_start = request_->context()->envoy_url().find("ohttp_config=");
+        DCHECK(ohttp_config_start != std::string::npos);
+        ohttp_config_start += 13;
+        size_t ohttp_config_end = request_->context()->envoy_url().find("&", ohttp_config_start);
+        if (ohttp_config_end == std::string::npos) {
+          ohttp_config_end = request_->context()->envoy_url().size();
+        }
+        std::string ohttp_config = request_->context()->envoy_url().substr(ohttp_config_start, ohttp_config_end - ohttp_config_start);
+        // base64 decode the envoy config
+        std::vector<uint8_t> envoy_config_decoded = base64_decode(ohttp_config);
+        std::vector<uint8_t> pkR_vec = ohttp::get_public_key(envoy_config_decoded);
+        DCHECK(pkR_vec.size() == pkR_len);
+        uint8_t pkR[pkR_len];
+        std::copy(pkR_vec.begin(), pkR_vec.end(), pkR);
+        sender_context = ohttp::createHpkeContext();
+        byte_data = ohttp::get_encapsulated_request(
+          sender_context,
+          request_info_.method,
+          request_info_.url.scheme(),
+          request_info_.url.host(),
+          request_info_.url.path(),
+          "", // TODO: read the provided upload_data_stream
+          client_enc, &client_enc_len,
+          pkR, pkR_len);
+        const char* request_data = reinterpret_cast<const char*>(byte_data.data());
+        std::vector<std::unique_ptr<UploadElementReader>> readers;
+        readers.push_back(
+          std::make_unique<net::UploadBytesElementReader>(request_data, byte_data.size()));
+        std::unique_ptr<UploadDataStream> upload_stream =
+          std::make_unique<ElementsUploadDataStream>(std::move(readers), 0);
+        SetUpload(upload_stream.release());
+      }
+    }
+
+    // This sets transaction_, so the upload must be changed before this point
     rv = request_->context()->http_transaction_factory()->CreateTransaction(
         priority_, &transaction_);
 
@@ -575,6 +630,7 @@ void URLRequestHttpJob::StartTransactionInternal() {
     }
 
     if (rv == OK) {
+
       transaction_->SetConnectedCallback(base::BindRepeating(
           &URLRequestHttpJob::NotifyConnectedCallback, base::Unretained(this)));
       transaction_->SetRequestHeadersCallback(request_headers_callback_);
@@ -587,6 +643,9 @@ void URLRequestHttpJob::StartTransactionInternal() {
 
         // Don't use the Envoy proxy when LOAD_BYPASS_PROXY is set
         // Specifically, we don't want to use Envoy for DoH requests
+        // Why don't we use it for DoH?
+        // How does Envoy allow proxying only some requests?
+        // This section actually routes our request through the proxy.
         if (!(request_info_.load_flags & LOAD_BYPASS_PROXY)) {
 
           if (request_->context()->envoy_url().rfind("http://", 0) == 0 ||
@@ -607,20 +666,27 @@ void URLRequestHttpJob::StartTransactionInternal() {
                 auto value = it.GetUnescapedValue();
                 if (key.compare("url") == 0) {
                   // see GetUnescapedValue, TODO check is_valid() before set
-                  request_info_.url =
-                      GURL(base::UnescapeURLComponent(value, base::UnescapeRule::NORMAL));
-              } else if (key.compare("salt") == 0) {
-                      salt = value;
+                  request_info_.url = GURL(base::UnescapeURLComponent(
+                      value, base::UnescapeRule::NORMAL));
+                } else if (key.compare("salt") == 0) {
+                  salt = value;
                 } else if (key.rfind(headerPrefix, 0) == 0 &&
-                          key.size() > headerPrefixLength) {
+                           key.size() > headerPrefixLength) {
+                  request_info_.extra_headers.SetHeader(
+                      key.substr(headerPrefixLength),
+                      value);  // check for header Host, add :authority for
+                               // http2; :path for http2
+                } else if (key.compare("ohttp") == 0) {
+                  request_info_.method = "POST";
                   request_info_.extra_headers.SetHeader(
-                      key.substr(headerPrefixLength), value); // check for header Host, add :authority for http2; :path for http2
+                    "Content-Type", "message/ohttp-req");
                 }
               }
             }
 
-
             // count for cache key
+            // So why do we use the digest?  It gets passed to the proxy, but not to the
+            // target server (that's good).
             auto digest = crypto::SHA256HashString(request_->url().spec() + salt);
             request_info_.url =
                 AppendQueryParameter(request_info_.url, "_digest", digest);
@@ -1561,22 +1627,61 @@ bool URLRequestHttpJob::ShouldFixMismatchedContentLength(int rv) const {
 int URLRequestHttpJob::ReadRawData(IOBuffer* buf, int buf_size) {
   DCHECK_NE(buf_size, 0);
   DCHECK(!read_in_progress_);
+  // This should be modified
+  // It should not give the caller data if the transaction is not done
+  // When the transaction *is* done, it should ohttp decapsulate it
+  // if necessary, and then give it to the caller
+  int rv;
+  if (!byte_data.empty()) {
+    scoped_refptr<IOBufferWithSize> tbuf = base::MakeRefCounted<IOBufferWithSize>(buf_size);
+    rv = transaction_->Read(tbuf.get(), buf_size,
+                                base::BindOnce(&URLRequestHttpJob::OnReadCompleted,
+                                               base::Unretained(this)));
+    // Read the contents of the temporary buffer into response data vector
+    if (rv > 0) {
+      response_data.insert(response_data.end(), tbuf->data(), tbuf->data() + rv);
+      size_t max_drequest_len = response_data.size();
+      uint8_t dresponse[max_drequest_len];
+      size_t dresponse_len;
+      ohttp::DecapsulationErrorCode decap_result = decapsulate_response(
+        sender_context, 
+        client_enc, 
+        client_enc_len, 
+        response_data,
+        dresponse,
+        &dresponse_len, 
+        max_drequest_len);
+      if (decap_result != ohttp::DecapsulationErrorCode::SUCCESS) {
+        return ERR_FAILED;  // Why did we fail? Are we not done reading from the network?  Handle that differently.
+      }
+      std::vector<uint8_t> dresponse_as_vec;
+      dresponse_as_vec.insert(dresponse_as_vec.end(), dresponse, dresponse + dresponse_len);
+      std::string body = ohttp::get_body_from_binary_response(dresponse_as_vec);
 
-  int rv =
-      transaction_->Read(buf, buf_size,
-                         base::BindOnce(&URLRequestHttpJob::OnReadCompleted,
-                                        base::Unretained(this)));
-
-  if (ShouldFixMismatchedContentLength(rv))
-    rv = OK;
-
-  if (rv == 0 || (rv < 0 && rv != ERR_IO_PENDING))
-    DoneWithRequest(FINISHED);
-
-  if (rv == ERR_IO_PENDING)
-    read_in_progress_ = true;
+      // Copy the decapsulated response into the buffer
+      memcpy(buf->data(), body.c_str(), body.size());
+      return dresponse_len;
+    } else {
+      DoneWithRequest(FINISHED);
+      return rv;
+    }
+  } else {
+    // usual control flow
+    rv =
+        transaction_->Read(buf, buf_size,
+                          base::BindOnce(&URLRequestHttpJob::OnReadCompleted,
+                                          base::Unretained(this)));
+    if (ShouldFixMismatchedContentLength(rv))
+      rv = OK;
 
-  return rv;
+    if (rv == 0 || (rv < 0 && rv != ERR_IO_PENDING)) {
+      DoneWithRequest(FINISHED);
+    }
+    if (rv == ERR_IO_PENDING) {
+      read_in_progress_ = true;
+    }
+    return rv;
+  }
 }
 
 int64_t URLRequestHttpJob::GetTotalReceivedBytes() const {
diff --git a/net/url_request/url_request_http_job.h b/net/url_request/url_request_http_job.h
index 866c8287a9b95..aba86e500b2db 100644
--- a/net/url_request/url_request_http_job.h
+++ b/net/url_request/url_request_http_job.h
@@ -31,6 +31,7 @@
 #include "net/url_request/url_request_job.h"
 #include "net/url_request/url_request_throttler_entry_interface.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/ohttp/ohttp.h"
 
 namespace net {
 
@@ -60,7 +61,11 @@ class NET_EXPORT_PRIVATE URLRequestHttpJob : public URLRequestJob {
   void SetEarlyResponseHeadersCallback(
       ResponseHeadersCallback callback) override;
   void SetResponseHeadersCallback(ResponseHeadersCallback callback) override;
-
+  std::vector<uint8_t> byte_data;
+  std::vector<uint8_t> response_data;
+  ohttp::OHTTP_HPKE_CTX* sender_context;
+  uint8_t client_enc[65];  // TODO: Don't hardcode this.  However, variables not permitted.
+  size_t client_enc_len;
  protected:
   URLRequestHttpJob(URLRequest* request,
                     const HttpUserAgentSettings* http_user_agent_settings);
diff --git a/net/url_request/url_request_job.cc b/net/url_request/url_request_job.cc
index 0127bbcf86499..a856f21a9a2b1 100644
--- a/net/url_request/url_request_job.cc
+++ b/net/url_request/url_request_job.cc
@@ -4,6 +4,7 @@
 
 #include "net/url_request/url_request_job.h"
 
+#include <iostream>
 #include <utility>
 
 #include "base/bind.h"
@@ -688,7 +689,6 @@ int URLRequestJob::ReadRawDataHelper(IOBuffer* buf,
   // TODO(xunjieli): Make ReadRawData take in a callback rather than requiring
   // subclass to call ReadRawDataComplete upon asynchronous completion.
   int result = ReadRawData(buf, buf_size);
-
   if (result != ERR_IO_PENDING) {
     // If the read completes synchronously, either success or failure, invoke
     // GatherRawReadStats so we can account for the completed read.
diff --git a/third_party/ohttp/BUILD.gn b/third_party/ohttp/BUILD.gn
new file mode 100644
index 0000000000000..e0cf6234938bc
--- /dev/null
+++ b/third_party/ohttp/BUILD.gn
@@ -0,0 +1,21 @@
+import("//testing/test.gni")
+
+source_set("ohttp") {
+  sources = [
+    "ohttp.cc",
+  ]
+  public = [
+    "ohttp.h"
+  ]
+  public_deps = [
+    "//third_party/boringssl",
+  ]
+}
+
+test("ohttp_test") {
+    sources = [ "ohttp_test.cc" ]
+    deps = [
+        ":ohttp",
+        "//testing/gtest:gtest",
+    ]
+}
\ No newline at end of file
diff --git a/third_party/ohttp/ohttp.cc b/third_party/ohttp/ohttp.cc
new file mode 100644
index 0000000000000..b88ca0d3e69e9
--- /dev/null
+++ b/third_party/ohttp/ohttp.cc
@@ -0,0 +1,864 @@
+#include <vector>
+#include <iostream>
+#include <stdexcept>
+
+#include "ohttp.h"
+#include "openssl/hkdf.h"
+#include "openssl/hpke.h"
+#include "openssl/err.h"
+#include "openssl/rand.h"
+
+namespace ohttp {
+
+    struct OHTTP_HPKE_CTX {
+        EVP_HPKE_CTX* internal_ctx;
+    };
+
+    OHTTP_HPKE_CTX* createHpkeContext() {
+        OHTTP_HPKE_CTX* ctx = new OHTTP_HPKE_CTX();
+        ctx->internal_ctx = EVP_HPKE_CTX_new();
+        return ctx;
+    }
+
+    void destroyHpkeContext(OHTTP_HPKE_CTX* ctx) {
+        EVP_HPKE_CTX_free(ctx->internal_ctx);
+        delete ctx;
+    }
+
+    struct OHTTP_HPKE_KEY {
+        EVP_HPKE_KEY* internal_key;
+    };
+
+    OHTTP_HPKE_KEY* createHpkeKey() {
+        OHTTP_HPKE_KEY* key = new OHTTP_HPKE_KEY();
+        key->internal_key = EVP_HPKE_KEY_new();
+        return key;
+    }
+
+    void destroyHpkeKey(OHTTP_HPKE_KEY* key) {
+        EVP_HPKE_KEY_free(key->internal_key);
+        delete key;
+    }
+
+    struct OHTTP_HPKE_KEM {
+        const EVP_HPKE_KEM* internal_kem;
+    };
+
+    OHTTP_HPKE_KEM* createHpkeKem() {
+        OHTTP_HPKE_KEM* kem = new OHTTP_HPKE_KEM();
+        kem->internal_kem = EVP_hpke_x25519_hkdf_sha256();
+        return kem;
+    }
+
+    void destroyHpkeKem(OHTTP_HPKE_KEM* kem) {
+        delete kem;
+    }
+
+    int OHTTP_HPKE_KEY_generate(OHTTP_HPKE_KEY* key, const OHTTP_HPKE_KEM* kem) {
+        return EVP_HPKE_KEY_generate(key->internal_key, kem->internal_kem);
+    }
+
+    bool OHTTP_HPKE_KEY_public_key(OHTTP_HPKE_KEY* key, uint8_t* out, size_t* out_len, size_t max_out) {
+        return EVP_HPKE_KEY_public_key(key->internal_key, out, out_len, max_out);
+    }
+
+    const int OHTTP_HPKE_MAX_PUBLIC_KEY_LENGTH = EVP_HPKE_MAX_PUBLIC_KEY_LENGTH;
+    const int OHTTP_HPKE_MAX_ENC_LENGTH = EVP_HPKE_MAX_ENC_LENGTH;
+
+    // Generates a config for a single keypair.
+    std::vector<uint8_t> generate_key_config(OHTTP_HPKE_KEY *keypair) {
+        // HPKE Symmetric Algorithms {
+        //   HPKE KDF ID (16),
+        //   HPKE AEAD ID (16),
+        // }
+
+        // Key Config {
+        //   Key Identifier (8),
+        //   HPKE KEM ID (16),
+        //   HPKE Public Key (Npk * 8),
+        //   HPKE Symmetric Algorithms Length (16) = 4..65532,
+        //   HPKE Symmetric Algorithms (32) ...,
+        // }
+        
+        std::vector<uint8_t> config;
+
+        // Key Identifier is always 0
+        config.push_back(0);
+
+        // KEM_ID
+        const EVP_HPKE_KEM *kem = EVP_HPKE_KEY_kem(keypair->internal_key);
+        const uint16_t kem_id = EVP_HPKE_KEM_id(kem);
+        const uint8_t kem_high_byte = (kem_id >> 8) & 0xFF;
+        const uint8_t kem_low_byte = kem_id & 0xFF;
+        config.push_back(kem_high_byte);
+        config.push_back(kem_low_byte);
+
+        // HPKE Public Key
+        uint8_t public_key[EVP_HPKE_MAX_PUBLIC_KEY_LENGTH];
+        size_t public_key_len;
+        EVP_HPKE_KEY* internal_key = keypair->internal_key;
+        if (!EVP_HPKE_KEY_public_key(internal_key, public_key, &public_key_len, sizeof(public_key))) {
+            config.clear();
+            return config;
+        }
+        std::cout << "Public key length: " << public_key_len << std::endl;
+        config.insert(config.end(), public_key, public_key + public_key_len);
+
+        // Symmetric Algorithms Length
+        config.push_back(0);
+        config.push_back(4);
+
+        // Hardcoded KDF and AEAD IDs
+        config.push_back(0x00);
+        config.push_back(0x01);
+        config.push_back(0x00);
+        config.push_back(0x01);
+
+        // Each encoded configuration is prefixed with a 2-byte integer in 
+        // network byte order that indicates the length of the key configuration
+        // in bytes. The length-prefixed encodings are concatenated to form a
+        // list.
+        const uint16_t length = config.size();
+        const uint8_t high_byte_length = (length >> 8) & 0xFF;
+        const uint8_t low_byte_length = length & 0xFF;
+        config.insert(config.begin(), low_byte_length);
+        config.insert(config.begin(), high_byte_length);
+
+        return config;
+    }
+
+    std::vector<uint8_t> get_public_key(std::vector<uint8_t> key_config) {
+        // Extract the public key from the key configuration.
+        // The public key starts at the 5th byte of the key configuration and is 32 bytes long.
+        std::vector<uint8_t> public_key(key_config.begin() + 5, key_config.begin() + 37);
+        return public_key;
+    }
+
+    // Helper to encode a string as a binary vector (length-prefixed)
+    std::vector<uint8_t> encode_string(const std::string& str) {
+        std::vector<uint8_t> result;
+
+        // WARNING: Cloudflare/Wood implementation uses just one byte
+        // where we would expect to see 2 per RFC 9292.
+
+        uint16_t length = str.size();
+        // TODO: Support QUIC-style multi-byte length encoding.
+        // see https://www.rfc-editor.org/rfc/rfc9000#section-16
+        // for now, just support short 6-bit lengths.
+        assert(length < 64);  // 2^6
+        result.push_back(length & 0xFF);
+        result.insert(result.end(), str.begin(), str.end());
+        return result;
+    }
+
+    OhttpParseErrorCode get_next_encoded_string(std::vector<uint8_t>& input, int offset, std::vector<uint8_t>& out, int& bytes_used) {
+        // Assume length is the first byte.
+        // TODO: Deal with QUIQ-style multi-byte length encoding.
+        int len_bytes = 1;
+        int start_content = offset + len_bytes;
+        int end_offset = start_content + input[offset];
+        if (end_offset > int(input.size())) {
+            return OhttpParseErrorCode::ERR_BAD_OFFSET;
+        }
+        bytes_used = end_offset - start_content + len_bytes;
+        for (int i = start_content; i < end_offset; i++) {
+            out.push_back(input[i]);
+        }
+        return OhttpParseErrorCode::SUCCESS;
+    }
+
+    // Function to encode the POST request in binary format per RFC 9292
+    std::vector<uint8_t> get_binary_request(const std::string& method, const std::string& scheme, const std::string& host, const std::string& path, const std::string& body) {
+        std::vector<uint8_t> binary_request;
+
+        // Known-Length Request {
+        //   Framing Indicator (i) = 0,
+        //   Request Control Data (..),
+        //   Known-Length Field Section (..),
+        //   Known-Length Content (..),
+        //   Known-Length Field Section (..),
+        //   Padding (..),
+        // }
+
+        // Framing indicator.  0 for fixed length request.
+        std::vector<uint8_t> framing_indicator = {0};
+        binary_request.insert(binary_request.end(), framing_indicator.begin(), framing_indicator.end());
+
+        // Control Data
+        // Request Control Data {
+        //   Method Length (i),
+        //   Method (..),
+        //   Scheme Length (i),
+        //   Scheme (..),
+        //   Authority Length (i),
+        //   Authority (..),
+        //   Path Length (i),
+        //   Path (..),
+        // }
+
+        // Method Length & Method
+        std::vector<uint8_t> method_value_field = encode_string(method);
+        binary_request.insert(binary_request.end(), method_value_field.begin(), method_value_field.end());
+
+        // Scheme Length & Scheme
+        std::vector<uint8_t> scheme_value_field = encode_string(scheme);
+        binary_request.insert(binary_request.end(), scheme_value_field.begin(), scheme_value_field.end());
+        
+        // Authority Length & Authority
+        std::string authority_value = host;
+        std::vector<uint8_t> authority_value_field = encode_string(authority_value);
+        binary_request.insert(binary_request.end(), authority_value_field.begin(), authority_value_field.end());
+
+        // Path Length & Path
+        std::vector<uint8_t> path_value_field = encode_string(path);
+        binary_request.insert(binary_request.end(), path_value_field.begin(), path_value_field.end());
+
+        // Header section.
+        // Known-Length Field Section {
+        //   Length (i),
+        //   Field Line (..) ...,
+        // }
+
+        // Length & Field Line
+        std::vector<uint8_t> no_fields = encode_string("");
+        binary_request.insert(binary_request.end(), no_fields.begin(), no_fields.end());
+
+        // Known-Length Content {
+        //   Content Length (i),
+        //   Content (..),
+        // }
+
+        // Content Length & Content
+        std::vector<uint8_t> body_field = encode_string(body);
+        binary_request.insert(binary_request.end(), body_field.begin(), body_field.end());
+
+        // Trailer section
+        // Known-Length Field Section {
+        //   Length (i),
+        //   Field Line (..) ...,
+        // }
+
+        // WARNING: Another deviation from cloudflare implementation
+
+        // Length & Field Line
+        binary_request.insert(binary_request.end(), no_fields.begin(), no_fields.end());
+
+        // No zero bytes.
+        return binary_request;
+    }
+
+    std::vector<uint8_t> get_quic_integer_as_bytes(uint64_t in) {
+        std::vector<uint8_t> encoded;
+
+        if (in <= 63ULL) {
+            encoded.push_back(static_cast<uint8_t>(in | 0b00'000000));
+        } else if (in <= 16383ULL) {
+            encoded.push_back(static_cast<uint8_t>((in >> 8) | 0b01'000000));
+            encoded.push_back(static_cast<uint8_t>(in & 0xFF));
+        } else if (in <= 1073741823ULL) {
+            encoded.push_back(static_cast<uint8_t>((in >> 24) | 0b10'000000));
+            encoded.push_back(static_cast<uint8_t>((in >> 16) & 0xFF));
+            encoded.push_back(static_cast<uint8_t>((in >> 8) & 0xFF));
+            encoded.push_back(static_cast<uint8_t>(in & 0xFF));
+        } else if (in <= 4611686018427387903ULL) {
+            encoded.push_back(static_cast<uint8_t>(((in >> 56) & 0b00111111) | 0b11'000000));
+            encoded.push_back(static_cast<uint8_t>((in >> 48) & 0xFF));
+            encoded.push_back(static_cast<uint8_t>((in >> 40) & 0xFF));
+            encoded.push_back(static_cast<uint8_t>((in >> 32) & 0xFF));
+            encoded.push_back(static_cast<uint8_t>((in >> 24) & 0xFF));
+            encoded.push_back(static_cast<uint8_t>((in >> 16) & 0xFF));
+            encoded.push_back(static_cast<uint8_t>((in >> 8) & 0xFF));
+            encoded.push_back(static_cast<uint8_t>(in & 0xFF));
+        }
+        return encoded;
+    }
+
+    uint64_t get_quic_integer_from_bytes(std::vector<uint8_t>& in) {
+        if (in.size() == 0) {
+            return -1;
+        }
+        uint64_t result = 0;
+        if (in.size() >= 1 && (in[0] & 0b11'000000) == 0b00'000000) {
+            result = in[0] & 0b00'111111;
+            in.erase(in.begin());
+        } else if (in.size() >= 2 && (in[0] & 0b11'000000) == 0b01'000000) {
+            result = (in[0] & 0b00'111111) << 8;
+            result |= in[1];
+            in.erase(in.begin(), in.begin() + 2);
+        } else if (in.size() >= 4 && (in[0] & 0b11'000000) == 0b10'000000) {
+            result = (in[0] & 0b00'111111) << 24;
+            result |= in[1] << 16;
+            result |= in[2] << 8;
+            result |= in[3];
+            in.erase(in.begin(), in.begin() + 4);
+        } else if (in.size() >= 8 && (in[0] & 0b11'000000) == 0b11'000000) {
+            result = static_cast<uint64_t>(in[0] & 0b00'111111) << 56;
+            result |= static_cast<uint64_t>(in[1]) << 48;
+            result |= static_cast<uint64_t>(in[2]) << 40;
+            result |= static_cast<uint64_t>(in[3]) << 32;
+            result |= static_cast<uint64_t>(in[4]) << 24;
+            result |= static_cast<uint64_t>(in[5]) << 16;
+            result |= static_cast<uint64_t>(in[6]) << 8;
+            result |= static_cast<uint64_t>(in[7]);
+            in.erase(in.begin(), in.begin() + 8);
+        } else {
+          return -1;
+        }
+        return result;
+    }
+
+    std::vector<uint8_t> get_binary_response(const int response_code, const std::vector<uint8_t>& content) {
+      // Known-Length Response {
+      std::vector<uint8_t> binary_response;
+      //   Framing Indicator (i) = 1,
+      binary_response.push_back(1); // Known-Length Informational Response
+      //   Known-Length Informational Response (..) ...,
+      //   Final Response Control Data {
+      //     Status Code (i) = 200..599,
+      std::vector<uint8_t> response_code_bytes = get_quic_integer_as_bytes(uint64_t(response_code));
+      binary_response.insert(binary_response.end(), response_code_bytes.begin(), response_code_bytes.end());   
+      //   }
+      //   Known-Length Field Section {
+      binary_response.push_back(0);
+      //     Length (i),
+      //     Field Line (..) ...,
+      //   }
+      //   Known-Length Content {
+      //     Content Length (i),
+      std::vector<uint8_t> content_size_bytes = get_quic_integer_as_bytes(uint64_t(content.size()));
+      binary_response.insert(binary_response.end(), content_size_bytes.begin(), content_size_bytes.end());
+      //     Content (..),
+      binary_response.insert(binary_response.end(), content.begin(), content.end());
+      //   }
+      //   Known-Length Field Section {
+      binary_response.push_back(0);
+      //     Length (i),
+      //     Field Line (..) ...,
+      //   }
+      //   Padding (..),
+      // }
+      return binary_response;
+    }
+
+    std::string get_url_from_binary_request(const std::vector<uint8_t>& binary_request) {
+        std::string url;
+        int offset = 0;
+        offset += 1; // Skip framing indicator
+        offset += 1 + binary_request[offset]; // Skip method
+        size_t scheme_length = binary_request[offset];
+        // Add Scheme to URL
+        for (size_t i = 0; i < scheme_length; i++) {
+            url.push_back(static_cast<char>(binary_request[offset + 1 + i]));
+        }
+        url += "://";
+        offset += 1 + scheme_length; // Skip scheme length and scheme
+        size_t authority_length = binary_request[offset];
+        for (size_t i = 0; i < authority_length; i++) {
+            url.push_back(static_cast<char>(binary_request[offset + 1 + i]));
+        }
+        offset += 1 + authority_length; // Skip authority length and authority
+        size_t path_length = binary_request[offset];
+        for (size_t i = 0; i < path_length; i++) {
+            url.push_back(static_cast<char>(binary_request[offset + 1 + i]));
+        }
+        return url;
+    }
+
+    std::string get_method_from_binary_request(const std::vector<uint8_t>& binary_request) {
+        std::string method;
+        size_t method_len = binary_request[1];
+        for (size_t i = 2; i < 2 + method_len; i++) {
+            method.push_back(static_cast<char>(binary_request[i]));
+        }
+        return method;
+    }
+
+    std::string get_body_from_binary_request(const std::vector<uint8_t>& binary_request) {
+        std::string body;
+        int offset = 0;
+        offset += 1; // Skip framing indicator
+        offset += 1 + binary_request[offset]; // Skip method
+        offset += 1 + binary_request[offset]; // Skip scheme
+        offset += 1 + binary_request[offset]; // Skip authority
+        offset += 1 + binary_request[offset]; // Skip path
+        offset += 1 + binary_request[offset]; // Skip header section
+        size_t body_length = binary_request[offset];
+        for (size_t i = 1; i <= body_length; i++) {
+            body.push_back(static_cast<char>(binary_request[offset + i]));
+        }
+        return body;
+    }
+
+    std::string get_body_from_binary_response(const std::vector<uint8_t>& binary_response) {
+        // Known-Length Response {
+        //   Framing Indicator (i) = 1,
+        //   Known-Length Informational Response (..) ...,
+        //   Final Response Control Data (..),
+        //   Known-Length Field Section (..),
+        //   Known-Length Content (..),
+        //   Known-Length Field Section (..),
+        //   Padding (..),
+        // }
+        std::vector<uint8_t> consumable_resp(binary_response.size());
+        std::copy(binary_response.begin(), binary_response.end(), consumable_resp.begin());
+        // Skip framing indicator
+        consumable_resp.erase(consumable_resp.begin());
+        // Assume no informational responses.
+        // Get response code
+        (void)get_quic_integer_from_bytes(consumable_resp);
+        // Skip field section
+        uint64_t field_section_length = get_quic_integer_from_bytes(consumable_resp);
+        consumable_resp.erase(consumable_resp.begin(), consumable_resp.begin() + field_section_length);
+        // Get content
+        uint64_t content_length = get_quic_integer_from_bytes(consumable_resp);
+        std::string body;
+        for (size_t i = 0; i < content_length; i++) {
+            body.push_back(static_cast<char>(consumable_resp[i]));
+        }
+        return body;
+    }
+
+    // TODO: Support configurable relay/gateway/keys.
+    std::vector<uint8_t> get_encapsulated_request(
+      OHTTP_HPKE_CTX* sender_context,
+      const std::string& method,
+      const std::string& scheme,
+      const std::string& host,
+      const std::string& path,
+      const std::string& body,
+      uint8_t* client_enc,
+      size_t* client_enc_len,
+      uint8_t* pkR,
+      size_t pkR_len) {
+        // Hard coded key config matching ohttp-gateway.jthess.com's
+        // public key.
+
+        // Plaintext:
+        std::vector<uint8_t> binary_request = get_binary_request(method, scheme, host, path, body);
+
+        // Info
+        // Build a sequence of bytes (info) by concatenating the ASCII-encoded
+        // string "message/bhttp request", a zero byte, and the header.
+        std::string infos = "message/bhttp request";
+        std::vector<uint8_t> info;
+        for (size_t i = 0; i < infos.size(); i++) {
+            info.push_back(uint8_t(infos[i]));
+        }
+        info.push_back(0);  // Zero byte
+        // Header
+        info.push_back(0x00); // Key ID
+        info.push_back(0x00); info.push_back(0x20); // HPKE KEM ID
+        info.push_back(0x00); info.push_back(0x01); // KDF ID
+        info.push_back(0x00); info.push_back(0x01); // AEAD ID
+
+        int rv = EVP_HPKE_CTX_setup_sender(
+            /* *ctx */ sender_context->internal_ctx,
+            /* *out_enc */ client_enc,
+            /* *out_enc_len */ client_enc_len,
+            /*  max_enc */ EVP_HPKE_MAX_ENC_LENGTH,
+            /* *kem */ EVP_hpke_x25519_hkdf_sha256(),  // We want 0x0020, DHKEM(X25519, HKDF-SHA256);	see: https://www.iana.org/assignments/hpke/hpke.xhtml
+            /* *kdf */ EVP_hpke_hkdf_sha256(),         // 0x0001, HKDF-SHA256
+            /* *aead */ EVP_hpke_aes_128_gcm(),        // 0x0001, AES-128-GCM
+            /* *peer_public_key */ pkR,
+            /*  peer_public_key_len */ pkR_len,
+            /* *info */ info.data(),
+            /*  info_len */ info.size()
+        );
+        if (rv != 1) {
+            return {};
+        }
+
+        // Have sender encrypt message for the recipient.
+        int ct_max_len = binary_request.size() +
+            EVP_HPKE_CTX_max_overhead(sender_context->internal_ctx);
+        std::vector<uint8_t> ciphertext(ct_max_len);
+        size_t ciphertext_len;
+        std::vector<uint8_t> ad = {};
+        rv = EVP_HPKE_CTX_seal(
+            /* *ctx */ sender_context->internal_ctx,
+            /* *out */ ciphertext.data(),
+            /* *out_len */ &ciphertext_len,
+            /*  max_out_len */ ciphertext.size(),
+            /* *in */ binary_request.data(),
+            /*  in_len */ binary_request.size(),
+            /* *ad */ ad.data(),
+            /*  ad_len */ ad.size()
+        );
+        if (rv != 1) {
+            return {};
+        }
+
+        // Per RFC 9292, the encapsulated request is the concatenation of the
+        // hdr, enc, and ciphertext.
+        std::vector<uint8_t> hdr = {
+            0x00, // Key ID
+            0x00, 0x20, // HPKE KEM ID
+            0x00, 0x01, // KDF ID
+            0x00, 0x01, // AEAD ID
+        };
+        std::vector<uint8_t> encapsulated_request;
+        encapsulated_request.insert(encapsulated_request.end(), hdr.begin(), hdr.end());
+        encapsulated_request.insert(encapsulated_request.end(), client_enc, client_enc + *client_enc_len);
+        encapsulated_request.insert(encapsulated_request.end(), ciphertext.begin(), ciphertext.begin() + ciphertext_len);
+
+        return encapsulated_request;
+    }
+
+    std::vector<uint8_t> encapsulate_response(
+        OHTTP_HPKE_CTX* receiver_context,
+        uint8_t* enc,
+        size_t enc_len,
+        const int response_code,
+        const std::string& response_body) {
+      std::vector<uint8_t> binary_response = get_binary_response(
+          response_code,
+          std::vector<uint8_t>(response_body.begin(), response_body.end()));
+      
+      // random(max(Nn, Nk))
+      size_t secret_len = 16;
+      std::vector<uint8_t> secret(secret_len);
+      std::string context_str = "message/bhttp response";
+      std::vector<uint8_t> context = std::vector<uint8_t>(context_str.begin(), context_str.end());
+      size_t context_len = context.size();
+      int rv = EVP_HPKE_CTX_export(
+        /* *ctx */ receiver_context->internal_ctx,
+        /* *out */ secret.data(),
+        /*  secret_len */ secret_len,
+        /* *context */ context.data(),
+        /*  context_len */ context_len
+      );
+      if (rv != 1) {
+        return {};
+      }
+
+      // Nonce of secret_len
+      std::vector<uint8_t> response_nonce(secret_len);
+      RAND_bytes(response_nonce.data(), secret_len);
+
+      // salt = concat(enc, response_nonce);
+      std::vector<uint8_t> salt(enc, enc + enc_len);
+      salt.insert(salt.end(), response_nonce.begin(), response_nonce.end());
+
+      // prk = Extract(salt, secret)
+      size_t prk_len;
+      uint8_t prk[EVP_MAX_MD_SIZE];
+      int rv2 = HKDF_extract(
+        /* *out_key */ prk,
+        /* *out_len */ &prk_len,
+        /* *digest */ EVP_sha256(),
+        /* *secret */ secret.data(),
+        /*  secret_len */ secret_len,
+        /* *salt */ salt.data(),
+        /*  salt_len */ salt.size()
+      );
+      if (rv2 != 1) {
+        return {};
+      }
+
+      // aead_key = Expand(prk, "key", Nk)
+      size_t aead_key_len = 16; // Nk
+      uint8_t aead_key[aead_key_len];
+      std::string info_key_str = "key";
+      uint8_t info_key[info_key_str.size()];
+      for (size_t i = 0; i < info_key_str.size(); i++) {
+        info_key[i] = info_key_str[i];
+      }
+      size_t info_key_len = sizeof(info_key);
+      int rv3 = HKDF_expand(
+        /* *out */ aead_key,
+        /*  out_len */ aead_key_len,
+        /* *digest */ EVP_sha256(),
+        /* *prk */ prk,
+        /*  prk_len */ prk_len,
+        /* *info */ info_key,
+        /*  info_len */ info_key_len
+      );
+      if (rv3 != 1) {
+        return {};
+      }
+
+      // aead_nonce = Expand(prk, "nonce", Nn)
+      size_t aead_nonce_len = 12; // Nn
+      uint8_t aead_nonce[aead_nonce_len];
+      std::string info_nonce_str = "nonce";
+      uint8_t info_nonce[info_nonce_str.size()];
+      for (size_t i = 0; i < info_nonce_str.size(); i++) {
+        info_nonce[i] = info_nonce_str[i];
+      }
+      size_t info_nonce_len = sizeof(info_nonce);
+      int rv4 = HKDF_expand(
+        /* *out */ aead_nonce,
+        /*  out_len */ aead_nonce_len,
+        /* *digest */ EVP_sha256(),
+        /* *prk */ prk,
+        /*  prk_len */ prk_len,
+        /* *info */ info_nonce,
+        /*  info_len */ info_nonce_len
+      );
+      if (rv4 != 1) {
+        return {};
+      }
+  
+      // ct = Seal(aead_key, aead_nonce, "", response)
+      const EVP_AEAD* aead = EVP_aead_aes_128_gcm();
+      EVP_AEAD_CTX *aead_ctx = EVP_AEAD_CTX_new(
+        /* *aead */ aead,
+        /* *key */ aead_key,
+        /*  key_len */ aead_key_len,
+        /*  tag_len */ EVP_AEAD_DEFAULT_TAG_LENGTH
+      );
+
+      size_t max_ct_len = binary_response.size() + EVP_AEAD_max_overhead(aead);
+      uint8_t ct[max_ct_len];
+      size_t ct_len;
+      size_t required_len = EVP_AEAD_nonce_length(aead);
+      if (required_len != aead_nonce_len) {
+        std::cout << "Nonce length mismatch, expected: " << required_len << "; got: " << aead_nonce_len << std::endl;
+        return {};
+      }
+      int rv5 = EVP_AEAD_CTX_seal(
+        /* *ctx */ aead_ctx,
+        /* *out */ ct,
+        /* *out_len */ &ct_len,
+        /*  max_out_len */ max_ct_len,
+        /* *nonce */ aead_nonce,
+        /*  nonce_len */ aead_nonce_len,
+        /* *in */ binary_response.data(),
+        /*  in_len */ binary_response.size(),
+        /* *ad */ nullptr,
+        /*  ad_len */ 0
+      );
+      if (rv5 != 1) {
+        return {};
+      }
+
+      // enc_response = concat(response_nonce, ct)
+      std::vector<uint8_t> enc_response;
+      enc_response.insert(enc_response.end(), response_nonce.begin(), response_nonce.end());
+      enc_response.insert(enc_response.end(), ct, ct + ct_len);
+
+      return enc_response;
+    }
+
+    DecapsulationErrorCode decapsulate_response(
+        OHTTP_HPKE_CTX* sender_context,
+        uint8_t* enc,
+        size_t enc_len,
+        std::vector<uint8_t> eresponse,
+        uint8_t* dresponse,
+        size_t* dresponse_len,
+        size_t max_drequest_len) {
+      // Separate into nonce and ciphertext
+      if (eresponse.size() < 12) {
+        std::cout << "return DecapsulationErrorCode::ERR_NO_AEAD_NONCE" << std::endl;
+        return DecapsulationErrorCode::ERR_NO_AEAD_NONCE;
+      }
+      std::vector<uint8_t> response_nonce(eresponse.begin(), eresponse.begin() + 16);
+      std::vector<uint8_t> ct(eresponse.begin() + 16, eresponse.end());
+      
+      size_t secret_len = 16;
+      std::vector<uint8_t> secret(secret_len);
+      std::string context_str = "message/bhttp response";
+      std::vector<uint8_t> context = std::vector<uint8_t>(context_str.begin(), context_str.end());
+      size_t context_len = context.size();
+      int rv = EVP_HPKE_CTX_export(
+        /* *ctx */ sender_context->internal_ctx,
+        /* *out */ secret.data(),
+        /*  secret_len */ secret_len,
+        /* *context */ context.data(),
+        /*  context_len */ context_len
+      );
+      if (rv != 1) {
+        std::cout << "return DecapsulationErrorCode::ERR_NO_SECRET" << std::endl;
+        return DecapsulationErrorCode::ERR_NO_SECRET;
+      }
+
+      // salt = concat(enc, response_nonce);
+      std::vector<uint8_t> salt(enc, enc + enc_len);
+      salt.insert(salt.end(), response_nonce.begin(), response_nonce.end());
+
+      // prk = Extract(salt, secret)
+      size_t prk_len;
+      uint8_t prk[EVP_MAX_MD_SIZE];
+      int rv2 = HKDF_extract(
+        /* *out_key */ prk,
+        /* *out_len */ &prk_len,
+        /* *digest */ EVP_sha256(),
+        /* *secret */ secret.data(),
+        /*  secret_len */ secret_len,
+        /* *salt */ salt.data(),
+        /*  salt_len */ salt.size()
+      );
+      if (rv2 != 1) {
+        std::cout << "return DecapsulationErrorCode::ERR_NO_PRK" << std::endl;
+        return DecapsulationErrorCode::ERR_NO_PRK;
+      }
+
+      // aead_key = Expand(prk, "key", Nk)
+      size_t aead_key_len = 16; // Nk
+      uint8_t aead_key[aead_key_len];
+      std::string info_key_str = "key";
+      uint8_t info_key[info_key_str.size()];
+      for (size_t i = 0; i < info_key_str.size(); i++) {
+        info_key[i] = info_key_str[i];
+      }
+      size_t info_key_len = sizeof(info_key);
+      int rv3 = HKDF_expand(
+        /* *out */ aead_key,
+        /*  out_len */ aead_key_len,
+        /* *digest */ EVP_sha256(),
+        /* *prk */ prk,
+        /*  prk_len */ prk_len,
+        /* *info */ info_key,
+        /*  info_len */ info_key_len
+      );
+      if (rv3 != 1) {
+        std::cout << "return DecapsulationErrorCode::ERR_NO_AEAD_KEY" << std::endl;
+        return DecapsulationErrorCode::ERR_NO_AEAD_KEY;
+      }
+
+      // aead_nonce = Expand(prk, "nonce", Nn)
+      size_t aead_nonce_len = 12; // Nn
+      uint8_t aead_nonce[aead_nonce_len];
+      std::string info_nonce_str = "nonce";
+      uint8_t info_nonce[info_nonce_str.size()];
+      for (size_t i = 0; i < info_nonce_str.size(); i++) {
+        info_nonce[i] = info_nonce_str[i];
+      }
+      size_t info_nonce_len = sizeof(info_nonce);
+      int rv4 = HKDF_expand(
+        /* *out */ aead_nonce,
+        /*  out_len */ aead_nonce_len,
+        /* *digest */ EVP_sha256(),
+        /* *prk */ prk,
+        /*  prk_len */ prk_len,
+        /* *info */ info_nonce,
+        /*  info_len */ info_nonce_len
+      );
+      if (rv4 != 1) {
+        std::cout << "return DecapsulationErrorCode::ERR_NO_AEAD_NONCE" << std::endl;
+        return DecapsulationErrorCode::ERR_NO_AEAD_NONCE;
+      }
+      const EVP_AEAD* aead = EVP_aead_aes_128_gcm();
+      EVP_AEAD_CTX *aead_ctx = EVP_AEAD_CTX_new(
+        /* *aead */ aead,
+        /* *key */ aead_key,
+        /*  key_len */ aead_key_len,
+        /*  tag_len */ EVP_AEAD_DEFAULT_TAG_LENGTH
+      );
+      size_t max_pt_len = eresponse.size();
+      uint8_t pt[max_pt_len];
+      size_t pt_len;
+      int rv5 = EVP_AEAD_CTX_open(
+        /* *ctx */ aead_ctx,
+        /* *out */ pt,
+        /* *out_len */ &pt_len,
+        /*  max_out_len */ max_pt_len,
+        /* *nonce */ aead_nonce,
+        /*  nonce_len */ aead_nonce_len,
+        /* *in */ ct.data(),
+        /*  in_len */ ct.size(),
+        /* *ad */ nullptr,
+        /*  ad_len */ 0
+      );
+      if (rv5 != 1) {
+        return DecapsulationErrorCode::ERR_UNABLE_TO_OPEN_RESPONSE;
+      }
+
+      // Set the values the caller expects.
+      if (pt_len > max_drequest_len) {
+        std::cout << "return DecapsulationErrorCode::ERR_NO_BUFFER_SPACE" << std::endl;
+        return DecapsulationErrorCode::ERR_NO_BUFFER_SPACE;
+      }
+      *dresponse_len = pt_len;
+      std::copy(pt, pt + pt_len, dresponse);
+
+      return DecapsulationErrorCode::SUCCESS;
+    }
+
+    DecapsulationErrorCode decapsulate_request(
+        OHTTP_HPKE_CTX* receiver_context,
+        std::vector<uint8_t> erequest,
+        uint8_t* drequest,
+        size_t* drequest_len,
+        uint8_t* enc,
+        size_t enc_len,
+        size_t max_drequest_len,
+        OHTTP_HPKE_KEY* recipient_keypair) {
+
+      // Break the request into 3 parts: hdr, ephemeral public key, and 
+      // ciphertext.
+
+      // The first 7 bytes of the encapsulated request are the hdr.
+      if (erequest.size() < 7) {
+        return DecapsulationErrorCode::ERR_NO_ENCAPSULATED_HEADER;
+      }
+      std::vector<uint8_t> hdr;
+      for (size_t i = 0; i < 7; i++) {
+        hdr.push_back(erequest[i]);
+      }
+
+      // The next 32 bytes are the ephemeral public key.
+      if (erequest.size() < 39) {
+        return DecapsulationErrorCode::ERR_NO_PUBLIC_KEY;
+      }
+      enc_len = 32;  // Hardcoded for now.
+      for (size_t i = 7; i < 39; i++) {
+        enc[i - 7] = erequest[i];
+      }
+
+      // The rest is the ciphertext.
+      std::vector<uint8_t> ct;
+      for (size_t i = 7 + enc_len; i < erequest.size(); i++) {
+        ct.push_back(erequest[i]);
+      }
+
+      // TODO: Get info (along with keys) from config.
+      // Info
+      // Build a sequence of bytes (info) by concatenating the ASCII-encoded
+      // string "message/bhttp request", a zero byte, and the header.
+      std::string infos = "message/bhttp request";
+      std::vector<uint8_t> info;
+      for (size_t i = 0; i < infos.size(); i++) {
+          info.push_back(uint8_t(infos[i]));
+      }
+      info.push_back(0);  // Zero byte
+      // Header
+      info.push_back(hdr[0]); // Key ID from header
+      // TODO: Use header to select algorithm.
+      info.push_back(0x00); info.push_back(0x20); // HPKE KEM ID
+      info.push_back(0x00); info.push_back(0x01); // KDF ID
+      info.push_back(0x00); info.push_back(0x01); // AEAD ID
+      
+      int rv2 = EVP_HPKE_CTX_setup_recipient(
+        /* *ctx */ receiver_context->internal_ctx,
+        /* *key */ recipient_keypair->internal_key,
+        /* *kdf */ EVP_hpke_hkdf_sha256(),
+        /* *aead */ EVP_hpke_aes_128_gcm(),
+        /* *enc */ enc,
+        /*  enc_len */ enc_len,
+        /* *info */ info.data(),
+        /*  info_len */ info.size()
+      );
+      if (rv2 != 1) {
+        return DecapsulationErrorCode::ERR_NO_CONTEXT_CREATED;
+      }
+
+      std::vector<uint8_t> ad = {};
+      int rv3 = EVP_HPKE_CTX_open(
+        /* *ctx */ receiver_context->internal_ctx,
+        /* *out */ drequest,
+        /* *out_len */ drequest_len,
+        /*  max_out_len */ max_drequest_len,
+        /* *ct */ ct.data(),
+        /*  ct_len */ ct.size(),
+        /* *ad */ ad.data(),
+        /*  ad_len */ ad.size()
+      );
+      if (rv3 != 1) {
+        return DecapsulationErrorCode::ERR_UNABLE_TO_OPEN;
+      }
+
+      return DecapsulationErrorCode::SUCCESS;
+    }
+}
\ No newline at end of file
diff --git a/third_party/ohttp/ohttp.h b/third_party/ohttp/ohttp.h
new file mode 100644
index 0000000000000..9cf994a5f9649
--- /dev/null
+++ b/third_party/ohttp/ohttp.h
@@ -0,0 +1,113 @@
+// Sketch of OHTTP implementation
+
+#ifndef OHTTP_H
+#define OHTTP_H
+
+// We hide exports to avoid exposing BoringSSL symbols
+// So, we need to export our own symbols
+#if defined _WIN32 || defined __CYGWIN__
+    #define OHTTP_EXPORT __declspec(dllexport)
+#else
+    #define OHTTP_EXPORT __attribute__((visibility("default")))
+#endif
+
+#include <cassert>
+#include <string>
+#include <vector>
+
+
+namespace ohttp {
+
+    // Wrappers for BoringSSL types
+    struct OHTTP_HPKE_CTX;
+    struct OHTTP_HPKE_KEY;
+    struct OHTTP_HPKE_KEM;
+    OHTTP_EXPORT OHTTP_HPKE_CTX* createHpkeContext();
+    OHTTP_EXPORT void destroyHpkeContext(OHTTP_HPKE_CTX* ctx);
+
+    OHTTP_EXPORT OHTTP_HPKE_KEY* createHpkeKey();
+    OHTTP_EXPORT void destroyHpkeKey(OHTTP_HPKE_KEY* key);
+
+    OHTTP_EXPORT OHTTP_HPKE_KEM* createHpkeKem();
+    OHTTP_EXPORT void destroyHpkeKem(OHTTP_HPKE_KEM* kem);
+
+    OHTTP_EXPORT int OHTTP_HPKE_KEY_generate(OHTTP_HPKE_KEY* key, const OHTTP_HPKE_KEM* kem);
+    OHTTP_EXPORT bool OHTTP_HPKE_KEY_public_key(OHTTP_HPKE_KEY* key, uint8_t* out, size_t* out_len, size_t max_out);
+
+    OHTTP_EXPORT extern const int OHTTP_HPKE_MAX_PUBLIC_KEY_LENGTH;
+    OHTTP_EXPORT extern const int OHTTP_HPKE_MAX_ENC_LENGTH;
+
+    enum class OHTTP_EXPORT DecapsulationErrorCode {
+        SUCCESS = 0,
+        ERR_NO_ENCAPSULATED_HEADER,
+        ERR_NO_PUBLIC_KEY,
+        ERR_NO_CIPHER_TEXT,
+        ERR_NO_CONTEXT_CREATED,
+        ERR_UNABLE_TO_OPEN,
+        ERR_NO_AEAD_NONCE,
+        ERR_NO_BUFFER_SPACE,
+        ERR_NO_SECRET,
+        ERR_NO_PRK,
+        ERR_NO_AEAD_KEY,
+        ERR_UNABLE_TO_OPEN_RESPONSE
+    };
+    OHTTP_EXPORT inline std::string DecapsulationErrorCodeToString(DecapsulationErrorCode code) {
+        switch (code) {
+            case DecapsulationErrorCode::SUCCESS: return "SUCCESS";
+            case DecapsulationErrorCode::ERR_NO_ENCAPSULATED_HEADER: return "ERR_NO_ENCAPSULATED_HEADER";
+            case DecapsulationErrorCode::ERR_NO_PUBLIC_KEY: return "ERR_NO_PUBLIC_KEY";
+            case DecapsulationErrorCode::ERR_NO_CIPHER_TEXT: return "ERR_NO_CIPHER_TEXT";
+            case DecapsulationErrorCode::ERR_NO_CONTEXT_CREATED: return "ERR_NO_CONTEXT_CREATED";
+            case DecapsulationErrorCode::ERR_UNABLE_TO_OPEN: return "ERR_UNABLE_TO_OPEN";
+            case DecapsulationErrorCode::ERR_NO_AEAD_NONCE: return "ERR_NO_AEAD_NONCE";
+            case DecapsulationErrorCode::ERR_NO_BUFFER_SPACE: return "ERR_NO_BUFFER_SPACE";
+            case DecapsulationErrorCode::ERR_NO_SECRET: return "ERR_NO_SECRET";
+            case DecapsulationErrorCode::ERR_NO_PRK: return "ERR_NO_PRK";
+            case DecapsulationErrorCode::ERR_NO_AEAD_KEY: return "ERR_NO_AEAD_KEY";
+            case DecapsulationErrorCode::ERR_UNABLE_TO_OPEN_RESPONSE: return "ERR_UNABLE_TO_OPEN_RESPONSE";
+            default: return "Unknown error code";
+        }
+    }
+    enum class OHTTP_EXPORT OhttpParseErrorCode {
+        SUCCESS = 0,
+        ERR_BAD_OFFSET,
+    };
+    OHTTP_EXPORT inline std::string OhttpParseErrorCodeToString(OhttpParseErrorCode code) {
+        switch (code) {
+            case OhttpParseErrorCode::SUCCESS: return "SUCCESS";
+            case OhttpParseErrorCode::ERR_BAD_OFFSET: return "ERR_BAD_OFFSET";
+            default: return "Unknown error code";
+        }
+    }
+
+    OHTTP_EXPORT std::vector<uint8_t> generate_key_config(OHTTP_HPKE_KEY *keypair);
+
+    OHTTP_EXPORT std::vector<uint8_t> get_public_key(std::vector<uint8_t> key_config);
+
+    OHTTP_EXPORT std::vector<uint8_t> encode_string(const std::string& str);
+
+    OHTTP_EXPORT OhttpParseErrorCode get_next_encoded_string(std::vector<uint8_t>& input, int offset, std::vector<uint8_t>& out, int& bytes_used);
+
+    OHTTP_EXPORT std::vector<uint8_t> get_binary_request(const std::string& method, const std::string& scheme, const std::string& host, const std::string& path, const std::string& body);
+
+    OHTTP_EXPORT std::vector<uint8_t> get_binary_response(const int response_code, const std::vector<uint8_t>& content);
+    
+    OHTTP_EXPORT std::string get_url_from_binary_request(const std::vector<uint8_t>& binary_request);
+
+    OHTTP_EXPORT std::string get_method_from_binary_request(const std::vector<uint8_t>& binary_request);
+
+    OHTTP_EXPORT std::string get_body_from_binary_request(const std::vector<uint8_t>& binary_request);
+
+    OHTTP_EXPORT std::string get_body_from_binary_response(const std::vector<uint8_t>& binary_response);
+
+    OHTTP_EXPORT std::vector<uint8_t> get_encapsulated_request(OHTTP_HPKE_CTX* sender_context, const std::string& method, const std::string& scheme, const std::string& host, const std::string& path, const std::string& body, uint8_t* client_enc, size_t* client_enc_len, uint8_t* pkR, size_t pkR_len);
+
+    OHTTP_EXPORT std::vector<uint8_t> encapsulate_response(OHTTP_HPKE_CTX* reciever_context, uint8_t* enc, size_t enc_len, const int response_code, const std::string& response_body);
+
+    OHTTP_EXPORT DecapsulationErrorCode decapsulate_request(OHTTP_HPKE_CTX* receiver_context, std::vector<uint8_t> erequest, uint8_t* drequest, size_t* drequest_len, uint8_t* enc, size_t enc_len, size_t max_drequest_len, OHTTP_HPKE_KEY* recipient_keypair);
+    
+    OHTTP_EXPORT DecapsulationErrorCode decapsulate_response(OHTTP_HPKE_CTX* sender_context, uint8_t* enc, size_t enc_len, std::vector<uint8_t> eresponse, uint8_t* dresponse, size_t* dresponse_len, size_t max_drequest_len);
+
+} // namespace ohttp
+
+#endif  // OHTTP_H
\ No newline at end of file
diff --git a/third_party/ohttp/ohttp_test.cc b/third_party/ohttp/ohttp_test.cc
new file mode 100644
index 0000000000000..c5633f1521c41
--- /dev/null
+++ b/third_party/ohttp/ohttp_test.cc
@@ -0,0 +1,404 @@
+#include <vector>
+
+#include "gtest/gtest.h"
+
+#include "ohttp.h"
+
+namespace {
+
+ohttp::OHTTP_HPKE_KEY* getKeys() {
+  // Use a newly derived keypair to do a roundtrip.
+  ohttp::OHTTP_HPKE_KEY* test_keypair = ohttp::createHpkeKey();
+  const ohttp::OHTTP_HPKE_KEM* kem = ohttp::createHpkeKem();
+  int rv = ohttp::OHTTP_HPKE_KEY_generate(test_keypair, kem);
+  EXPECT_EQ(rv, 1); // Check if key generation was successful
+  return test_keypair;
+}
+
+TEST(OhttpTest, GetKeyConfig) {
+  ohttp::OHTTP_HPKE_KEY* keypair = getKeys();
+  std::vector<uint8_t> key_config = ohttp::generate_key_config(keypair);
+
+  // 2 byte length plus one config
+  EXPECT_EQ(key_config.size(), size_t(2 + 1 + 2 + 32 + 2 + 4));
+
+  // First 2 bytes are remaining length
+  EXPECT_EQ(key_config[0], 0);
+  EXPECT_EQ(key_config[1], 1 + 2 + 32 + 2 + 4);
+}
+
+TEST(OhttpTest, ExtractPublicKeyFromConfig) {
+  ohttp::OHTTP_HPKE_KEY* keypair = getKeys();
+  uint8_t public_key[ohttp::OHTTP_HPKE_MAX_PUBLIC_KEY_LENGTH];
+  size_t public_key_len;
+  EXPECT_TRUE(ohttp::OHTTP_HPKE_KEY_public_key(keypair, public_key, &public_key_len, sizeof(public_key)));
+  std::vector<uint8_t> public_key_vec(public_key, public_key + public_key_len);
+
+  std::vector<uint8_t> key_config = ohttp::generate_key_config(keypair);
+  std::vector<uint8_t> config_public_key = ohttp::get_public_key(key_config);
+
+  EXPECT_EQ(config_public_key.size(), size_t(32));
+  EXPECT_EQ(config_public_key, public_key_vec);
+}
+
+// Test encoding strings.
+TEST(EncodeStringTest, TestEncodeString) {
+  std::string input = "hello";
+  // Length is a 2-byte number.
+  std::vector<uint8_t> expected = {5, 'h', 'e', 'l', 'l', 'o'};
+  EXPECT_EQ(ohttp::encode_string(input), expected);
+}
+
+// Test extracting encoded strings.
+TEST(DecodeStringTest, TestDecodeString) {
+  int starting_offset = 0;
+  std::vector<uint8_t> input = {5, 0x42, 0x43, 0x44, 0x45, 0x46, 1, 0x47};
+  std::vector<uint8_t> expected = {0x42, 0x43, 0x44, 0x45, 0x46};
+  std::vector<uint8_t> output;
+  int bytes_used;
+  EXPECT_EQ(ohttp::get_next_encoded_string(input, starting_offset, output, bytes_used), ohttp::OhttpParseErrorCode::SUCCESS);
+  EXPECT_EQ(output, expected);
+  EXPECT_EQ(bytes_used, 6);
+  int next_offset = starting_offset + bytes_used;
+  expected = {0x47};
+  std::vector<uint8_t> output2;
+  EXPECT_EQ(ohttp::get_next_encoded_string(input, next_offset, output2, bytes_used), ohttp::OhttpParseErrorCode::SUCCESS);
+  EXPECT_EQ(output2, expected);
+  EXPECT_EQ(bytes_used, 2);
+}
+
+// Test binary request creation per https://www.rfc-editor.org/rfc/rfc9292
+TEST(OhttpTest, TestBinaryRequest) {
+  std::vector<uint8_t> request =
+      ohttp::get_binary_request("POST", "https", "ohttp-gateway.jthess.com", "/", "foo");
+  std::vector<uint8_t> expected = {
+      // Known-Length Request {
+      //   Framing Indicator (i) = 0,
+      //   Request Control Data (..),
+      //   Known-Length Field Section (..),
+      //   Known-Length Content (..),
+      //   Known-Length Field Section (..),
+      //   Padding (..),
+      // }
+
+      // Framing Indicator
+      0,
+
+      // Control Data
+      // Request Control Data {
+      //   Method Length (i),
+      4,
+      //   Method (..),
+      'P', 'O', 'S', 'T',  // Method Length & Method
+      //   Scheme Length (i),
+      5,
+      //   Scheme (..),
+      'h', 't', 't', 'p', 's',
+      //   Authority Length (i),
+      24,
+      //   Authority (..),
+      'o', 'h', 't', 't', 'p', '-', 'g', 'a', 't', 'e', 'w', 'a', 'y', '.', 'j',
+      't', 'h', 'e', 's', 's', '.', 'c', 'o', 'm',
+      //   Path Length (i),
+      1,
+      //   Path (..),
+      // }
+      '/',
+
+      // Header section.
+      // Known-Length Field Section {
+      //   Length (i),
+      0,
+      //   Field Line (..) ...,
+      // }
+
+      // Known-Length Content {
+      //   Content Length (i),
+      3,
+      //   Content (..),
+      'f', 'o', 'o',
+      // }
+
+      // Trailer section.
+      // Known-Length Field Section {
+      //   Length (i),
+      0,
+      //   Field Line (..) ...,
+      // }
+  };
+  EXPECT_EQ(request, expected);
+}
+
+TEST(OhttpTest, TestBinaryResponse) {
+  std::string response_message = "this is a response";
+  std::vector<uint8_t> response_message_vec = std::vector<uint8_t>(response_message.begin(), response_message.end());
+  std::vector<uint8_t> response = ohttp::get_binary_response(200, response_message_vec);
+  std::vector<uint8_t> expected = {
+    // Known-Length Response {
+    //   Framing Indicator (i) = 1,
+    //   Known-Length Informational Response (..) ...,
+    //   Final Response Control Data (..),
+    //   Known-Length Field Section (..),
+    //   Known-Length Content (..),
+    //   Known-Length Field Section (..),
+    //   Padding (..),
+    // }
+    1,
+
+    // No informational responses in this test.
+    // Known-Length Informational Response {
+    //   Informational Response Control Data (..),
+    //   Known-Length Field Section (..),
+    // }
+
+    // Final Response Control Data {
+    //   Status Code (i) = 200..599,
+    // }
+    200,
+
+    // Known-Length Field Section {
+    //   Length (i),
+    //   Field Line (..) ...,
+    // }
+    0,
+
+    // Known-Length Content {
+    //   Content Length (i),
+    //   Content (..),
+    // }
+    18, // Length of "this is a response"
+    't', 'h', 'i', 's', ' ', 'i', 's', ' ', 'a', ' ', 'r', 'e', 's', 'p', 'o', 'n', 's', 'e',
+
+    // Trailer section.
+    // Known-Length Field Section {
+    //   Length (i),
+    //   Field Line (..) ...,
+    // }
+    0,
+  };
+  EXPECT_EQ(response, expected);
+}
+
+TEST(OhttpTest, EncapsulateAndDecapsulateResponse) {
+  ohttp::OHTTP_HPKE_KEY* test_keypair = getKeys();
+  uint8_t client_enc[ohttp::OHTTP_HPKE_MAX_ENC_LENGTH];
+  size_t client_enc_len;
+  uint8_t pkR[ohttp::OHTTP_HPKE_MAX_PUBLIC_KEY_LENGTH];
+  size_t pkR_len;
+  int rv = ohttp::OHTTP_HPKE_KEY_public_key(
+      test_keypair, pkR, &pkR_len, ohttp::OHTTP_HPKE_MAX_PUBLIC_KEY_LENGTH);
+  EXPECT_EQ(rv, 1);
+
+  ohttp::OHTTP_HPKE_CTX* sender_context = ohttp::createHpkeContext();
+  std::vector<uint8_t> encapsulated_request =
+      ohttp::get_encapsulated_request(
+        sender_context,
+        "POST", "https", "ohttp-gateway.jthess.com", "/", "foo",
+        client_enc,
+        &client_enc_len,
+        pkR,
+        pkR_len);
+  std::cout << std::endl;
+  ohttp::OHTTP_HPKE_CTX* receiver_context = ohttp::createHpkeContext();
+  size_t max_req_out_len = encapsulated_request.size();
+  std::vector<uint8_t> request_bhttp(max_req_out_len);
+  size_t req_out_len;
+  size_t enc_len = 32;
+  u_int8_t enc[enc_len];
+  ohttp::DecapsulationErrorCode rv2 = ohttp::decapsulate_request(
+    receiver_context,
+    encapsulated_request,
+    request_bhttp.data(),
+    &req_out_len,
+    enc,
+    enc_len,
+    max_req_out_len,
+    test_keypair);
+  EXPECT_EQ(rv2, ohttp::DecapsulationErrorCode::SUCCESS);
+
+  // Give a made up response.
+  std::vector<uint8_t> encapsulated_response = ohttp::encapsulate_response(
+    receiver_context,
+    enc,
+    enc_len,
+    200,
+    "this is a response");
+  // Be sure its actually populated; we'll verify contents below.
+  EXPECT_GT(encapsulated_response.size(), size_t(32 + 18));
+
+  // Then decapsulate the response back at the sender.
+  size_t max_resp_out_len = encapsulated_response.size();
+  uint8_t response_bhttp[max_resp_out_len];
+  size_t resp_out_len;
+  ohttp::DecapsulationErrorCode rv3 = ohttp::decapsulate_response(
+    sender_context,
+    client_enc,
+    client_enc_len,
+    encapsulated_response,
+    response_bhttp,
+    &resp_out_len,
+    max_resp_out_len);
+  EXPECT_EQ(rv3, ohttp::DecapsulationErrorCode::SUCCESS);
+
+  EXPECT_EQ(resp_out_len, size_t(23)); // 18 plus the BHTTP encoding
+  EXPECT_EQ(response_bhttp[0], 1);     // Fixed length response
+  EXPECT_EQ(response_bhttp[1], 200);   // Status code (Improperly encoded.  Fix this.)
+}
+
+TEST(OhttpTest, ParseBinaryRequest)
+{
+  std::vector<uint8_t> request =
+      ohttp::get_binary_request("POST", "https", "ohttp-gateway.jthess.com", "/", "foo");
+
+  std::string method = ohttp::get_method_from_binary_request(request);
+  std::string expected_method = "POST";
+  EXPECT_EQ(method, expected_method);
+
+  std::string url = ohttp::get_url_from_binary_request(request);
+  std::string expected_url = "https://ohttp-gateway.jthess.com/";
+  EXPECT_EQ(url, expected_url);
+
+  std::string body = ohttp::get_body_from_binary_request(request);
+  std::string expected_body = "foo";
+  EXPECT_EQ(body, expected_body);
+}
+
+// Test that encapsulation starts with the correct header.
+TEST(OhttpTest, TestEncapsulatedRequestHeader) {
+  // Encapsulation per RFC 9458:
+  // https://www.rfc-editor.org/rfc/rfc9458
+
+  // hdr = concat(encode(1, key_id),
+  //              encode(2, kem_id),
+  //              encode(2, kdf_id),
+  //              encode(2, aead_id))
+  // info = concat(encode_str("message/bhttp request"),
+  //               encode(1, 0),
+  //               hdr)
+  // enc, sctxt = SetupBaseS(pkR, info)
+  // ct = sctxt.Seal("", request)
+  // enc_request = concat(hdr, enc, ct)
+
+  ohttp::OHTTP_HPKE_KEY* test_keypair = getKeys();
+  uint8_t client_enc[ohttp::OHTTP_HPKE_MAX_ENC_LENGTH];
+  size_t client_enc_len;
+  uint8_t pkR[ohttp::OHTTP_HPKE_MAX_PUBLIC_KEY_LENGTH];
+  size_t pkR_len;
+  int rv = ohttp::OHTTP_HPKE_KEY_public_key(
+      test_keypair, pkR, &pkR_len, ohttp::OHTTP_HPKE_MAX_PUBLIC_KEY_LENGTH);
+  EXPECT_EQ(rv, 1); // Check if public key retrieval was successful
+
+  ohttp::OHTTP_HPKE_CTX* sender_context = ohttp::createHpkeContext();
+  std::vector<uint8_t> request =
+      ohttp::get_encapsulated_request(
+        sender_context, 
+        "POST", "https", "ohttp-gateway.jthess.com", "/", "foo",
+        client_enc, &client_enc_len,
+        pkR, pkR_len);
+
+  std::vector<uint8_t> expected_hdr = {
+      0x80,        // Key ID
+      0x00, 0x20,  // HPKE KEM ID
+      0x00, 0x01,  // KDF ID
+      0x00, 0x01,  // AEAD ID
+  };
+
+  // hdr portion of the encapsulated request is the first 7 bytes of request.
+  int hdr_length = 7;
+  std::vector<uint8_t> actual_hdr(hdr_length);
+  std::copy(request.begin() + 0, request.begin() + hdr_length,
+            actual_hdr.begin());
+  EXPECT_EQ(expected_hdr, actual_hdr);
+
+  // enc and ct vary.  Their creation is outsourced to HPKE implementation from
+  // openssl.
+}
+
+TEST(OhttpTest, DecapsulateEmptyRequestFails) {
+  ohttp::OHTTP_HPKE_KEY* test_keypair = getKeys();
+  size_t pkR_len = 32;
+  uint8_t pkR[pkR_len];
+  size_t written;
+  int rv = ohttp::OHTTP_HPKE_KEY_public_key(
+      test_keypair, pkR, &written, pkR_len);
+  EXPECT_EQ(rv, 1); // Check if public key retrieval was successful
+
+  // Now, decapsulate it with the same keypair
+  ohttp::OHTTP_HPKE_CTX* receiver_context = ohttp::createHpkeContext();
+  std::vector<uint8_t> empty_request = {};
+  std::vector<uint8_t> request_bhttp(0);
+  size_t out_len;
+  size_t enc_len = 32;
+  uint8_t enc[enc_len];
+  ohttp::DecapsulationErrorCode rv2 = ohttp::decapsulate_request(
+    receiver_context,
+    empty_request,
+    request_bhttp.data(),
+    &out_len,
+    enc,
+    enc_len,
+    0,
+    test_keypair);
+  EXPECT_EQ(rv2, ohttp::DecapsulationErrorCode::ERR_NO_ENCAPSULATED_HEADER);
+}
+
+// Enc/Decapsulate routrip test
+TEST(OhttpTest, EncapsulateAndDecapsulateRequest) {
+  // Recipient keys
+  ohttp::OHTTP_HPKE_KEY* test_keypair = getKeys();
+  uint8_t client_enc[ohttp::OHTTP_HPKE_MAX_ENC_LENGTH];
+  size_t client_enc_len;
+  uint8_t pkR[ohttp::OHTTP_HPKE_MAX_PUBLIC_KEY_LENGTH];
+  size_t pkR_len;
+  int rv = ohttp::OHTTP_HPKE_KEY_public_key(
+      test_keypair, pkR, &pkR_len, ohttp::OHTTP_HPKE_MAX_PUBLIC_KEY_LENGTH);
+  EXPECT_EQ(rv, 1); // Check if public key retrieval was successful
+
+  // Encapsulate it
+  ohttp::OHTTP_HPKE_CTX* sender_context = ohttp::createHpkeContext();
+  std::vector<uint8_t> request =
+      ohttp::get_encapsulated_request(
+        sender_context,
+        "POST", "https", "ohttp-gateway.jthess.com", "/", "foo",
+        client_enc, &client_enc_len,
+        pkR, pkR_len);
+
+  ohttp::OHTTP_HPKE_CTX* receiver_context = ohttp::createHpkeContext();
+  size_t max_out_len = request.size();
+  std::vector<uint8_t> request_bhttp(max_out_len);
+  size_t out_len;
+  size_t enc_len = 32;
+  uint8_t enc[enc_len];
+  ohttp::DecapsulationErrorCode rv2 = ohttp::decapsulate_request(
+    receiver_context,
+    request,
+    request_bhttp.data(),
+    &out_len,
+    enc,
+    enc_len,
+    max_out_len,
+    test_keypair);
+  EXPECT_EQ(rv2, ohttp::DecapsulationErrorCode::SUCCESS);
+
+  std::vector<uint8_t> expected_bhttp = ohttp::get_binary_request("POST", "https", "ohttp-gateway.jthess.com", "/", "foo");
+  EXPECT_EQ(out_len, expected_bhttp.size());
+  std::vector<uint8_t> request_bhttp_vec(request_bhttp.data(), request_bhttp.data() + out_len);
+  EXPECT_EQ(request_bhttp_vec, expected_bhttp);
+}
+
+// Enc/Decapsulate routrip test
+TEST(OhttpTest, ParseBHTTPResponse) {
+  std::string response_message = "bar";
+  std::vector<uint8_t> resp_text = std::vector<uint8_t>(response_message.begin(), response_message.end());
+  std::vector<uint8_t> response = ohttp::get_binary_response(200, resp_text);
+
+  std::string parsed_message = ohttp::get_body_from_binary_response(response);
+  EXPECT_EQ(parsed_message, response_message);
+}
+
+}  // namespace
+
+int main(int argc, char** argv) {
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
\ No newline at end of file
