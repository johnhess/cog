diff --git a/components/cronet/BUILD.gn b/components/cronet/BUILD.gn
index 92350cf3b4b77..685dd0a147bca 100644
--- a/components/cronet/BUILD.gn
+++ b/components/cronet/BUILD.gn
@@ -275,6 +275,7 @@ if (is_android) {
     deps = [
       "//components/cronet",
       "//components/cronet/native:cronet_native_headers",
+      "//third_party/boringssl",
     ]
     if ((is_linux || is_chromeos) && !is_component_build) {
       public_configs = [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
diff --git a/components/cronet/native/sample/main.cc b/components/cronet/native/sample/main.cc
index 007d5bbab90d7..0276c927c29df 100644
--- a/components/cronet/native/sample/main.cc
+++ b/components/cronet/native/sample/main.cc
@@ -3,46 +3,33 @@
 // found in the LICENSE file.
 
 #include <iostream>
+#include <vector>
+#include <string>
+#include <cstdint>
 
 #include "cronet_c.h"
 #include "sample_executor.h"
 #include "sample_url_request_callback.h"
+#include "third_party/boringssl/src/include/openssl/hpke.h"
 
 Cronet_EnginePtr CreateCronetEngine() {
   Cronet_EnginePtr cronet_engine = Cronet_Engine_Create();
   Cronet_EngineParamsPtr engine_params = Cronet_EngineParams_Create();
   Cronet_EngineParams_user_agent_set(engine_params, "CronetSample/1");
 
-  Cronet_EngineParams_envoy_url_set(engine_params,
-                                    "https://example.com/enovy_path/");
+  // Standard HTTPS Proxy using Envoy's ansible roles.
   Cronet_EngineParams_envoy_url_set(
       engine_params,
       "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&resolve=MAP%20example.com%201.2.3.4");
-  // only MAP url-host to address
+      "?url=https%3A%2F%2Fenvoy-proxies.jthess.com%2Fenvoy_proxy_path%2F&header_Host="
+      "ohttp-gateway.jthess.com");
   Cronet_EngineParams_envoy_url_set(
       engine_params,
       "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&address=1.2.3.4");
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&address=1.2.3.4&disabled_cipher_suites=0xc024,0xc02f");
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
-      "subdomain.example.com&address=1.2.3.4&disabled_cipher_suites=0xc024,0xc02f");
-  Cronet_EngineParams_envoy_url_set(engine_params, "socks5://127.0.0.1:1080");
-  // proxy URL and SOCKS5 together (for true PTs)
-  Cronet_EngineParams_envoy_url_set(
-      engine_params,
-      "envoy://"
-      "?url=https%3A%2F%2Frayon.example.com%2Fwikipedia%2F&address=142.65.13.41"
-      "&header_Host=abc.example.com&socks5=socks5%3A%2F%2Flocalhost%3A8192");
+      "?url=https%3A%2F%2Fohttp-relay.jthess.com" // Relay
+      "&ohttp=1" // Flag to indicate this is an ohttp relay
+      "&ohttp_gateway=ohttp-gateway.jthess.com"   // Explicit Gateway
+  );
  
   Cronet_EngineParams_enable_quic_set(engine_params, true);
 
@@ -72,6 +59,7 @@ void PerformRequest(Cronet_EnginePtr cronet_engine,
             << url_request_callback.response_as_string() << std::endl;
 }
 
+
 // Download a resource from the Internet. Optional argument must specify
 // a valid URL.
 int main(int argc, const char* argv[]) {
@@ -80,7 +68,7 @@ int main(int argc, const char* argv[]) {
   std::cout << "Cronet version: "
             << Cronet_Engine_GetVersionString(cronet_engine) << std::endl;
 
-  std::string url(argc > 1 ? argv[1] : "https://www.google.com/generate_204");
+  std::string url(argc > 1 ? argv[1] : "https://www.example.com");
   std::cout << "URL: " << url << std::endl;
   SampleExecutor executor;
   PerformRequest(cronet_engine, url, executor.GetExecutor());
diff --git a/components/cronet/native/sample/sample_url_request_callback.cc b/components/cronet/native/sample/sample_url_request_callback.cc
index 396e27dbd27d2..79ddccc0d1ae1 100644
--- a/components/cronet/native/sample/sample_url_request_callback.cc
+++ b/components/cronet/native/sample/sample_url_request_callback.cc
@@ -56,6 +56,7 @@ void SampleUrlRequestCallback::OnReadCompleted(Cronet_UrlRequestPtr request,
   std::string last_read_data(
       reinterpret_cast<char*>(Cronet_Buffer_GetData(buffer)), bytes_read);
   response_as_string_ += last_read_data;
+  std::cout << response_as_string_ << std::endl;
   // Continue reading the response.
   Cronet_UrlRequest_Read(request, buffer);
 }
diff --git a/components/cronet/native/sample/test/sample_test.cc b/components/cronet/native/sample/test/sample_test.cc
index 7831b69f72a4a..ee0e6167ada44 100644
--- a/components/cronet/native/sample/test/sample_test.cc
+++ b/components/cronet/native/sample/test/sample_test.cc
@@ -44,7 +44,7 @@ TEST(SampleTest, TestConnectionRefused) {
   EXPECT_NE(std::string::npos, sample_out.find("net::ERR_INVALID_URL"));
 }
 
-}  // namespace
+}
 
 int main(int argc, char** argv) {
   s_test_app_path = argv[0];
diff --git a/net/BUILD.gn b/net/BUILD.gn
index e12e5b6936b8d..bbd05f79d0072 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -1078,6 +1078,7 @@ component("net") {
     "//net/dns:mdns_client",
     "//net/dns/public",
     "//net/third_party/quiche",
+    "//third_party/ohttp",
   ]
 
   allow_circular_includes_from = [
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index b3b5b9da8f5ae..8d847d267e228 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -55,6 +55,7 @@
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
 #include "net/url_request/url_request_throttler_manager.h"
+#include "third_party/ohttp/ohttp.h"
 #include "url/url_constants.h"
 
 #if BUILDFLAG(ENABLE_REPORTING)
@@ -286,8 +287,12 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   context->set_require_network_isolation_key(require_network_isolation_key_);
   context->set_network_quality_estimator(network_quality_estimator_);
 
-  if (!envoy_url_.empty())
+  // Give the context the Envoy URL
+  if (!envoy_url_.empty()) {
     context->set_envoy_url(envoy_url_);
+    std::cout << "Envoy URL is: " << envoy_url_ << std::endl;
+    std::cout << "Our Request is: " << ohttp::GetFoo() << std::endl;
+  }
   if (http_user_agent_settings_) {
     context->set_http_user_agent_settings(std::move(http_user_agent_settings_));
   } else {
@@ -380,6 +385,7 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   // TODO assert value
   auto url = GURL(value);
 
+  // Set resolve/address/MAP, if specified.
   if (GetValueForKeyInQuery(envoy_url, "resolve", &value)) {
     std::unique_ptr<net::MappedHostResolver> remapped_resolver(
         new net::MappedHostResolver(std::move(host_resolver_)));
@@ -399,6 +405,7 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   } else {
     SSLContextConfig ssl_context_config;
     std::vector<uint16_t> disabled_ciphers;
+    // Disable cipher suites, if specified
     if (GetValueForKeyInQuery(envoy_url, "disabled_cipher_suites", &value)) {
       auto cipher_strings = base::SplitString(value, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
       // see net::ParseCipherSuites(cipher_strings);
diff --git a/net/url_request/url_request_http_job.cc b/net/url_request/url_request_http_job.cc
index da6ee48808da0..aa451221ad3a0 100644
--- a/net/url_request/url_request_http_job.cc
+++ b/net/url_request/url_request_http_job.cc
@@ -36,6 +36,7 @@
 #include "base/values.h"
 #include "build/build_config.h"
 #include "base/strings/escape.h"
+#include "net/base/elements_upload_data_stream.h"
 #include "net/base/features.h"
 #include "net/base/host_port_pair.h"
 #include "net/base/http_user_agent_settings.h"
@@ -47,6 +48,7 @@
 #include "net/base/privacy_mode.h"
 #include "net/base/registry_controlled_domains/registry_controlled_domain.h"
 #include "net/base/trace_constants.h"
+#include "net/base/upload_bytes_element_reader.h"
 #include "net/base/url_util.h"
 #include "net/cert/cert_status_flags.h"
 #include "net/cert/ct_policy_status.h"
@@ -94,6 +96,7 @@
 #include "net/url_request/url_request_throttler_manager.h"
 #include "net/url_request/websocket_handshake_userdata_key.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/ohttp/ohttp.h"
 #include "url/gurl.h"
 #include "url/origin.h"
 #include "url/url_constants.h"
@@ -538,6 +541,7 @@ void URLRequestHttpJob::MaybeStartTransactionInternal(int result) {
 
 void URLRequestHttpJob::StartTransactionInternal() {
   DCHECK(!override_response_headers_);
+  std::cout << "Trying to hit: " << request_info_.url << std::endl;
 
   // NOTE: This method assumes that request_info_ is already setup properly.
 
@@ -560,6 +564,25 @@ void URLRequestHttpJob::StartTransactionInternal() {
   } else {
     DCHECK(request_->context()->http_transaction_factory());
 
+    // refactor this with the same conditional below
+    if (!(request_info_.load_flags & LOAD_BYPASS_PROXY)) {
+      if (request_->context()->envoy_url().rfind("http://", 0) == 0 ||
+                    request_->context()->envoy_url().rfind("https://", 0) == 0 ||
+                    request_->context()->envoy_url().rfind("envoy://", 0) == 0) {
+        // Override the response since we need to decrypt it
+        std::cout << "Constructing an HPKE encapsulated binary request" << std::endl;
+        byte_data = ohttp::get_encapsulated_request("/", "ohttp-gateway.jthess.com", "foo");
+        const char* request_data = reinterpret_cast<const char*>(byte_data.data());
+        std::vector<std::unique_ptr<UploadElementReader>> readers;
+        readers.push_back(
+          std::make_unique<net::UploadBytesElementReader>(request_data, byte_data.size()));
+        std::unique_ptr<UploadDataStream> upload_stream =
+          std::make_unique<ElementsUploadDataStream>(std::move(readers), 0);
+        SetUpload(upload_stream.release());
+      }
+    }
+
+    // This sets transaction_, so the upload must be changed before this point
     rv = request_->context()->http_transaction_factory()->CreateTransaction(
         priority_, &transaction_);
 
@@ -575,6 +598,7 @@ void URLRequestHttpJob::StartTransactionInternal() {
     }
 
     if (rv == OK) {
+
       transaction_->SetConnectedCallback(base::BindRepeating(
           &URLRequestHttpJob::NotifyConnectedCallback, base::Unretained(this)));
       transaction_->SetRequestHeadersCallback(request_headers_callback_);
@@ -587,6 +611,9 @@ void URLRequestHttpJob::StartTransactionInternal() {
 
         // Don't use the Envoy proxy when LOAD_BYPASS_PROXY is set
         // Specifically, we don't want to use Envoy for DoH requests
+        // Why don't we use it for DoH?
+        // How does Envoy allow proxying only some requests?
+        // This section actually routes our request through the proxy.
         if (!(request_info_.load_flags & LOAD_BYPASS_PROXY)) {
 
           if (request_->context()->envoy_url().rfind("http://", 0) == 0 ||
@@ -607,20 +634,30 @@ void URLRequestHttpJob::StartTransactionInternal() {
                 auto value = it.GetUnescapedValue();
                 if (key.compare("url") == 0) {
                   // see GetUnescapedValue, TODO check is_valid() before set
-                  request_info_.url =
-                      GURL(base::UnescapeURLComponent(value, base::UnescapeRule::NORMAL));
-              } else if (key.compare("salt") == 0) {
-                      salt = value;
+                  request_info_.url = GURL(base::UnescapeURLComponent(
+                      value, base::UnescapeRule::NORMAL));
+                } else if (key.compare("salt") == 0) {
+                  salt = value;
                 } else if (key.rfind(headerPrefix, 0) == 0 &&
-                          key.size() > headerPrefixLength) {
+                           key.size() > headerPrefixLength) {
+                  request_info_.extra_headers.SetHeader(
+                      key.substr(headerPrefixLength),
+                      value);  // check for header Host, add :authority for
+                               // http2; :path for http2
+                } else if (key.compare("ohttp") == 0) {
+                  // Do OHTTP Things
+                  // TODO: HPKE-encapsulated version of original request.
+                  request_info_.method = "POST";
                   request_info_.extra_headers.SetHeader(
-                      key.substr(headerPrefixLength), value); // check for header Host, add :authority for http2; :path for http2
+                    "Content-Type", "message/ohttp-req");
                 }
               }
             }
 
 
             // count for cache key
+            // So why do we use the digest?  It gets passed to the proxy, but not to the
+            // target server (that's good).
             auto digest = crypto::SHA256HashString(request_->url().spec() + salt);
             request_info_.url =
                 AppendQueryParameter(request_info_.url, "_digest", digest);
diff --git a/net/url_request/url_request_http_job.h b/net/url_request/url_request_http_job.h
index 866c8287a9b95..fd26d87b87e2a 100644
--- a/net/url_request/url_request_http_job.h
+++ b/net/url_request/url_request_http_job.h
@@ -60,7 +60,7 @@ class NET_EXPORT_PRIVATE URLRequestHttpJob : public URLRequestJob {
   void SetEarlyResponseHeadersCallback(
       ResponseHeadersCallback callback) override;
   void SetResponseHeadersCallback(ResponseHeadersCallback callback) override;
-
+  std::vector<uint8_t> byte_data;
  protected:
   URLRequestHttpJob(URLRequest* request,
                     const HttpUserAgentSettings* http_user_agent_settings);
diff --git a/third_party/ohttp/BUILD.gn b/third_party/ohttp/BUILD.gn
new file mode 100644
index 0000000000000..e0cf6234938bc
--- /dev/null
+++ b/third_party/ohttp/BUILD.gn
@@ -0,0 +1,21 @@
+import("//testing/test.gni")
+
+source_set("ohttp") {
+  sources = [
+    "ohttp.cc",
+  ]
+  public = [
+    "ohttp.h"
+  ]
+  public_deps = [
+    "//third_party/boringssl",
+  ]
+}
+
+test("ohttp_test") {
+    sources = [ "ohttp_test.cc" ]
+    deps = [
+        ":ohttp",
+        "//testing/gtest:gtest",
+    ]
+}
\ No newline at end of file
diff --git a/third_party/ohttp/ohttp.cc b/third_party/ohttp/ohttp.cc
new file mode 100644
index 0000000000000..0bef527f86e7c
--- /dev/null
+++ b/third_party/ohttp/ohttp.cc
@@ -0,0 +1,309 @@
+#include <vector>
+#include <iostream>
+#include <stdexcept>
+
+#include "third_party/ohttp/ohttp.h"
+#include "third_party/boringssl/src/include/openssl/hpke.h"
+
+namespace ohttp {
+
+    const char* GetFoo() {
+        return "foo";
+    }
+
+    // Helper to encode a string as a binary vector (length-prefixed)
+    std::vector<uint8_t> encode_string(const std::string& str) {
+        std::vector<uint8_t> result;
+
+        // WARNING: Cloudflare/Wood implementation uses just one byte
+        // where we would expect to see 2 per RFC 9292.
+
+        uint16_t length = str.size();
+        // TODO: Support QUIC-style multi-byte length encoding.
+        // see https://www.rfc-editor.org/rfc/rfc9000#section-16
+        // for now, just support short 6-bit lengths.
+        assert(length < 64);  // 2^6
+        result.push_back(length & 0xFF);
+        result.insert(result.end(), str.begin(), str.end());
+        return result;
+    }
+
+    OhttpParseErrorCode get_next_encoded_string(std::vector<uint8_t>& input, int offset, std::vector<uint8_t>& out, int& bytes_used) {
+        // Assume length is the first byte.
+        // TODO: Deal with QUIQ-style multi-byte length encoding.
+        int len_bytes = 1;
+        int start_content = offset + len_bytes;
+        int end_offset = start_content + input[offset];
+        if (end_offset > int(input.size())) {
+            return OhttpParseErrorCode::ERR_BAD_OFFSET;
+        }
+        bytes_used = end_offset - start_content + len_bytes;
+        for (int i = start_content; i < end_offset; i++) {
+            out.push_back(input[i]);
+        }
+        return OhttpParseErrorCode::SUCCESS;
+    }
+
+    // Function to encode the POST request in binary format per RFC 9292
+    std::vector<uint8_t> get_binary_request(const std::string& path, const std::string& host, const std::string& body) {
+        std::vector<uint8_t> binary_request;
+
+        // Known-Length Request {
+        //   Framing Indicator (i) = 0,
+        //   Request Control Data (..),
+        //   Known-Length Field Section (..),
+        //   Known-Length Content (..),
+        //   Known-Length Field Section (..),
+        //   Padding (..),
+        // }
+
+        // Framing indicator.  0 for fixed length request.
+        std::vector<uint8_t> framing_indicator = {0};
+        binary_request.insert(binary_request.end(), framing_indicator.begin(), framing_indicator.end());
+
+        // Control Data
+        // Request Control Data {
+        //   Method Length (i),
+        //   Method (..),
+        //   Scheme Length (i),
+        //   Scheme (..),
+        //   Authority Length (i),
+        //   Authority (..),
+        //   Path Length (i),
+        //   Path (..),
+        // }
+
+        // Method Length & Method
+        std::string method_value = "POST";
+        std::vector<uint8_t> method_value_field = encode_string(method_value);
+        // std::cout << "Method value field size: " << method_value_field.size() << std::endl;
+        // std::cout << "Method value field: ";
+        // for (uint8_t byte : method_value_field) {
+        //     std::cout << (int)byte << " ";
+        // }
+        binary_request.insert(binary_request.end(), method_value_field.begin(), method_value_field.end());
+
+        // Scheme Length & Scheme
+        std::string scheme_value = "https";
+        std::vector<uint8_t> scheme_value_field = encode_string(scheme_value);
+        binary_request.insert(binary_request.end(), scheme_value_field.begin(), scheme_value_field.end());
+        
+        // Authority Length & Authority
+        std::string authority_value = host;
+        std::vector<uint8_t> authority_value_field = encode_string(authority_value);
+        binary_request.insert(binary_request.end(), authority_value_field.begin(), authority_value_field.end());
+
+        // Path Length & Path
+        std::vector<uint8_t> path_value_field = encode_string(path);
+        binary_request.insert(binary_request.end(), path_value_field.begin(), path_value_field.end());
+
+        // Header section.
+        // Known-Length Field Section {
+        //   Length (i),
+        //   Field Line (..) ...,
+        // }
+
+        // Length & Field Line
+        std::vector<uint8_t> no_fields = encode_string("");
+        binary_request.insert(binary_request.end(), no_fields.begin(), no_fields.end());
+
+        // Known-Length Content {
+        //   Content Length (i),
+        //   Content (..),
+        // }
+
+        // Content Length & Content
+        std::vector<uint8_t> body_field = encode_string(body);
+        binary_request.insert(binary_request.end(), body_field.begin(), body_field.end());
+
+        // Trailer section
+        // Known-Length Field Section {
+        //   Length (i),
+        //   Field Line (..) ...,
+        // }
+
+        // WARNING: Another deviation from cloudflare implementation
+
+        // Length & Field Line
+        binary_request.insert(binary_request.end(), no_fields.begin(), no_fields.end());
+
+        // No zero bytes.
+        return binary_request;
+    }
+
+    // TODO: Support configurable relay/gateway/keys.
+    std::vector<uint8_t> get_encapsulated_request(const std::string& path, const std::string& host, const std::string& body, uint8_t* pkR, size_t pkR_len) {
+        // Hard coded key config matching ohttp-gateway.jthess.com's
+        // public key.
+
+        // Key ID (8 bit)                 80
+        // HPKE KEM ID (16)               0020 
+        // HPKE Public Key (8*Npk=8*32)   ea0060b17d5c7216e6f7d22ba14e337e6602b96d3435b6445b09180880edf81d
+        // HPKE Symmetric Algos Len (16)  0004
+        // HPKE Symmetric algorithms (32) 
+        //   HPKE KDF ID                  0001
+        //   HPKE AEAD ID                 0001
+
+        // Plaintext:
+        std::vector<uint8_t> binary_request = get_binary_request(path, host, body);
+
+        // Info
+        // Build a sequence of bytes (info) by concatenating the ASCII-encoded
+        // string "message/bhttp request", a zero byte, and the header.
+        std::string infos = "message/bhttp request";
+        std::vector<uint8_t> info;
+        for (size_t i = 0; i < infos.size(); i++) {
+            info.push_back(uint8_t(infos[i]));
+        }
+        info.push_back(0);  // Zero byte
+        // Header
+        info.push_back(0x80); // Key ID
+        info.push_back(0x00); info.push_back(0x20); // HPKE KEM ID
+        info.push_back(0x00); info.push_back(0x01); // KDF ID
+        info.push_back(0x00); info.push_back(0x01); // AEAD ID
+
+        // Ciphertext & Friends:
+        std::vector<uint8_t> encapsulated_request;  // will be aad + enc + ct
+
+        // Create a context
+        bssl::ScopedEVP_HPKE_CTX sender_context;
+
+        // Ephemeral public key
+        uint8_t enc[EVP_HPKE_MAX_ENC_LENGTH];
+        size_t enc_len;
+
+        int rv = EVP_HPKE_CTX_setup_sender(
+            /* *ctx */ sender_context.get(),
+            /* *out_enc */ enc,
+            /* *out_enc_len */ &enc_len,
+            /*  max_enc */ sizeof(enc),
+            /* *kem */ EVP_hpke_x25519_hkdf_sha256(),  // We want 0x0020, DHKEM(X25519, HKDF-SHA256);	see: https://www.iana.org/assignments/hpke/hpke.xhtml
+            /* *kdf */ EVP_hpke_hkdf_sha256(),         // 0x0001, HKDF-SHA256
+            /* *aead */ EVP_hpke_aes_128_gcm(),        // 0x0001, AES-128-GCM
+            /* *peer_public_key */ pkR,
+            /*  peer_public_key_len */ pkR_len,
+            /* *info */ info.data(),
+            /*  info_len */ info.size()
+        );
+        if (rv != 1) {
+            return {};
+        }
+
+        // Have sender encrypt message for the recipient.
+        int ct_max_len = binary_request.size() +
+            EVP_HPKE_CTX_max_overhead(sender_context.get());
+        std::vector<uint8_t> ciphertext(ct_max_len);
+        size_t ciphertext_len;
+        std::vector<uint8_t> aad = {
+            0x80, // Key ID
+            0x00, 0x20, // HPKE KEM ID
+            0x00, 0x01, // KDF ID
+            0x00, 0x01, // AEAD ID
+        };
+        rv = EVP_HPKE_CTX_seal(
+            /* *ctx */ sender_context.get(),
+            /* *out */ ciphertext.data(),
+            /* *out_len */ &ciphertext_len,
+            /*  max_out_len */ ciphertext.size(),
+            /* *in */ binary_request.data(),
+            /*  in_len */ binary_request.size(),
+            /* *ad */ aad.data(),
+            /*  ad_len */ aad.size()
+        );
+        if (rv != 1) {
+            return {};
+        }
+
+        // Per RFC 9292, the encapsulated request is the concatenation of the
+        // aad, enc, and ciphertext.
+        encapsulated_request.insert(encapsulated_request.end(), aad.begin(), aad.end());
+        encapsulated_request.insert(encapsulated_request.end(), enc, enc + enc_len);
+        encapsulated_request.insert(encapsulated_request.end(), ciphertext.begin(), ciphertext.begin() + ciphertext_len);
+
+        return encapsulated_request;
+    }
+
+    DecapsulationErrorCode decapsulate_request(
+        std::vector<uint8_t> erequest,
+        uint8_t* drequest,
+        size_t* drequest_len,
+        size_t max_drequest_len,
+        EVP_HPKE_KEY recipient_keypair) {
+
+      // Break the request into 3 parts: AAD, ephemeral public key, and 
+      // ciphertext.
+
+      // The first 7 bytes of the encapsulated request are the aad.
+      if (erequest.size() < 7) {
+        return DecapsulationErrorCode::ERR_NO_ENCAPSULATED_HEADER;
+      }
+      std::vector<uint8_t> ad;
+      for (size_t i = 0; i < 7; i++) {
+        ad.push_back(erequest[i]);
+      }
+
+      // The next 32 bytes are the ephemeral public key.
+      if (erequest.size() < 39) {
+        return DecapsulationErrorCode::ERR_NO_PUBLIC_KEY;
+      }
+      size_t enc_len = 32;  // Hardcoded for now.
+      std::vector<uint8_t> enc;
+      for (size_t i = 7; i < 7 + enc_len; i++) {
+        enc.push_back(erequest[i]);
+      }
+
+      // The rest is the ciphertext.
+      std::vector<uint8_t> ct;
+      for (size_t i = 7 + enc_len; i < erequest.size(); i++) {
+        ct.push_back(erequest[i]);
+      }
+
+      // TODO: Get info (along with keys) from config.
+      // Info
+      // Build a sequence of bytes (info) by concatenating the ASCII-encoded
+      // string "message/bhttp request", a zero byte, and the header.
+      std::string infos = "message/bhttp request";
+      std::vector<uint8_t> info;
+      for (size_t i = 0; i < infos.size(); i++) {
+          info.push_back(uint8_t(infos[i]));
+      }
+      info.push_back(0);  // Zero byte
+      // Header
+      info.push_back(0x80); // Key ID
+      info.push_back(0x00); info.push_back(0x20); // HPKE KEM ID
+      info.push_back(0x00); info.push_back(0x01); // KDF ID
+      info.push_back(0x00); info.push_back(0x01); // AEAD ID
+      
+      // Create a context
+      bssl::ScopedEVP_HPKE_CTX receiver_context;
+      int rv2 = EVP_HPKE_CTX_setup_recipient(
+        /* *ctx */ receiver_context.get(),
+        /* *key */ &recipient_keypair,
+        /* *kdf */ EVP_hpke_hkdf_sha256(),
+        /* *aead */ EVP_hpke_aes_128_gcm(),
+        /* *enc */ enc.data(),
+        /*  enc_len */ enc.size(),
+        /* *info */ info.data(),
+        /*  info_len */ info.size()
+      );
+      if (rv2 != 1) {
+        return DecapsulationErrorCode::ERR_NO_CONTEXT_CREATED;
+      }
+
+      int rv3 = EVP_HPKE_CTX_open(
+        /* *ctx */ receiver_context.get(),
+        /* *out */ drequest,
+        /* *out_len */ drequest_len,
+        /*  max_out_len */ max_drequest_len,
+        /* *ct */ ct.data(),
+        /*  ct_len */ ct.size(),
+        /* *ad */ ad.data(),
+        /*  ad_len */ ad.size()
+      );
+      if (rv3 != 1) {
+        return DecapsulationErrorCode::ERR_UNABLE_TO_OPEN;
+      }
+
+      return DecapsulationErrorCode::SUCCESS;
+    }
+}
\ No newline at end of file
diff --git a/third_party/ohttp/ohttp.h b/third_party/ohttp/ohttp.h
new file mode 100644
index 0000000000000..bd7b365362fc0
--- /dev/null
+++ b/third_party/ohttp/ohttp.h
@@ -0,0 +1,42 @@
+// Sketch of OHTTP implementation
+
+#ifndef OHTTP_H
+#define OHTTP_H
+
+#include <cassert>
+#include <string>
+#include <vector>
+
+#include "third_party/boringssl/src/include/openssl/hpke.h"
+
+
+namespace ohttp {
+    enum class DecapsulationErrorCode {
+        SUCCESS = 0,
+        ERR_NO_ENCAPSULATED_HEADER,
+        ERR_NO_PUBLIC_KEY,
+        ERR_NO_CIPHER_TEXT,
+        ERR_NO_CONTEXT_CREATED,
+        ERR_UNABLE_TO_OPEN,
+    };
+    enum class OhttpParseErrorCode {
+        SUCCESS = 0,
+        ERR_BAD_OFFSET,
+    };
+
+    // A function that simply returns the string "foo"
+    const char* GetFoo();
+
+    std::vector<uint8_t> encode_string(const std::string& str);
+
+    OhttpParseErrorCode get_next_encoded_string(std::vector<uint8_t>& input, int offset, std::vector<uint8_t>& out, int& bytes_used);
+
+    std::vector<uint8_t> get_binary_request(const std::string& path, const std::string& host, const std::string& body);
+    
+    std::vector<uint8_t> get_encapsulated_request(const std::string& path, const std::string& host, const std::string& body, uint8_t* pkR, size_t pkR_len);
+
+    DecapsulationErrorCode decapsulate_request(std::vector<uint8_t> erequest, uint8_t* drequest, size_t* drequest_len, size_t max_drequest_len, EVP_HPKE_KEY recipient_keypair);
+
+} // namespace ohttp
+
+#endif  // OHTTP_H
\ No newline at end of file
diff --git a/third_party/ohttp/ohttp_test.cc b/third_party/ohttp/ohttp_test.cc
new file mode 100644
index 0000000000000..ae756890a5243
--- /dev/null
+++ b/third_party/ohttp/ohttp_test.cc
@@ -0,0 +1,294 @@
+#include <vector>
+
+#include "testing/gtest/include/gtest/gtest.h"
+
+#include "third_party/boringssl/src/include/openssl/hpke.h"
+#include "third_party/ohttp/ohttp.h"
+#include "third_party/boringssl/src/crypto/test/test_util.h" // Bytes
+
+namespace {
+
+EVP_HPKE_KEY getKeys() {
+  // Use a newly derived keypair to do a roundtrip.
+  EVP_HPKE_KEY *test_keypair = EVP_HPKE_KEY_new();
+  const EVP_HPKE_KEM *kem = EVP_hpke_x25519_hkdf_sha256();
+  int rv = EVP_HPKE_KEY_generate(test_keypair, kem);
+  EXPECT_EQ(rv, 1); // Check if key generation was successful
+  return *test_keypair;
+}
+
+// Exercise the HPKE library without testing our code just as
+// as a proof of concept to compare our code against.
+TEST(OhttpTest, TestVector1) {
+  const EVP_HPKE_KEM *kem = EVP_hpke_x25519_hkdf_sha256();    // 32
+  const EVP_HPKE_KDF *kdf = EVP_hpke_hkdf_sha256();           // 1
+  const EVP_HPKE_AEAD *aead = EVP_hpke_aes_128_gcm();         // 1
+
+  EXPECT_TRUE(aead);
+  EXPECT_TRUE(kdf);
+
+  // Recipient keypair
+  std::vector<uint8_t> public_key_r_ = {0x39, 0x48, 0xcf, 0xe0, 0xad, 0x1d, 0xdb, 0x69, 0x5d, 0x78, 0x0e, 0x59, 0x07, 0x71, 0x95, 0xda, 0x6c, 0x56, 0x50, 0x6b, 0x02, 0x73, 0x29, 0x79, 0x4a, 0xb0, 0x2b, 0xca, 0x80, 0x81, 0x5c, 0x4d};
+  std::vector<uint8_t> secret_key_r_ = {0x46, 0x12, 0xc5, 0x50, 0x26, 0x3f, 0xc8, 0xad, 0x58, 0x37, 0x5d, 0xf3, 0xf5, 0x57, 0xaa, 0xc5, 0x31, 0xd2, 0x68, 0x50, 0x90, 0x3e, 0x55, 0xa9, 0xf2, 0x3f, 0x21, 0xd8, 0x53, 0x4e, 0x8a, 0xc8};
+
+  std::vector<uint8_t> info_ = {0x44, 0x20, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x61, 0x20, 0x47, 0x72, 0x65, 0x63, 0x69, 0x61, 0x6e, 0x20, 0x55, 0x72, 0x6e};
+  
+  // First round
+  std::vector<uint8_t> aad = {0x43, 0x6f, 0x75, 0x6e, 0x74, 0x2d, 0x30}; 
+  std::vector<uint8_t> ct = {0xf9, 0x38, 0x55, 0x8b, 0x5d, 0x72, 0xf1, 0xa2, 0x38, 0x10, 0xb4, 0xbe, 0x2a, 0xb4, 0xf8, 0x43, 0x31, 0xac, 0xc0, 0x2f, 0xc9, 0x7b, 0xab, 0xc5, 0x3a, 0x52, 0xae, 0x82, 0x18, 0xa3, 0x55, 0xa9, 0x6d, 0x87, 0x70, 0xac, 0x83, 0xd0, 0x7b, 0xea, 0x87, 0xe1, 0x3c, 0x51, 0x2a};
+  std::vector<uint8_t> nonce = {0x56, 0xd8, 0x90, 0xe5, 0xac, 0xca, 0xaf, 0x01, 0x1c, 0xff, 0x4b, 0x7d};
+  std::vector<uint8_t> pt = {0x42, 0x65, 0x61, 0x75, 0x74, 0x79, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x2c, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x20, 0x62, 0x65, 0x61, 0x75, 0x74, 0x79};
+  
+  // Ephemeral keys
+  std::vector<uint8_t> secret_key_e_ = {0x52, 0xc4, 0xa7, 0x58, 0xa8, 0x02, 0xcd, 0x8b, 0x93, 0x6e, 0xce, 0xea, 0x31, 0x44, 0x32, 0x79, 0x8d, 0x5b, 0xaf, 0x2d, 0x7e, 0x92, 0x35, 0xdc, 0x08, 0x4a, 0xb1, 0xb9, 0xcf, 0xa2, 0xf7, 0x36};
+  std::vector<uint8_t> public_key_e_ = {0x37, 0xfd, 0xa3, 0x56, 0x7b, 0xdb, 0xd6, 0x28, 0xe8, 0x86, 0x68, 0xc3, 0xc8, 0xd7, 0xe9, 0x7d, 0x1d, 0x12, 0x53, 0xb6, 0xd4, 0xea, 0x6d, 0x44, 0xc1, 0x50, 0xf7, 0x41, 0xf1, 0xbf, 0x44, 0x31};
+
+  bssl::ScopedEVP_HPKE_CTX sender_ctx;
+  uint8_t enc[EVP_HPKE_MAX_ENC_LENGTH];  // len is 32
+  size_t enc_len;
+  // Like our usual setup, but with known seed in secrect_key_e_.
+  EXPECT_TRUE(EVP_HPKE_CTX_setup_sender_with_seed_for_testing(
+      sender_ctx.get(), enc, &enc_len, sizeof(enc), kem, kdf, aead,
+      public_key_r_.data(), public_key_r_.size(), info_.data(), info_.size(),
+      secret_key_e_.data(), secret_key_e_.size()));
+
+  std::vector<uint8_t> enc_vec(enc, enc + enc_len);
+  EXPECT_EQ(enc_vec, public_key_e_);
+
+  // Verify first output
+  std::vector<uint8_t> encrypted(pt.size() + EVP_HPKE_CTX_max_overhead(sender_ctx.get()));
+  size_t encrypted_len;
+  EXPECT_EQ(1, EVP_HPKE_CTX_seal(sender_ctx.get(), encrypted.data(), &encrypted_len,
+                                 encrypted.size(), pt.data(),
+                                 pt.size(), aad.data(),
+                                 aad.size()));
+  std::vector<uint8_t> encrypted_vec(encrypted.data(), encrypted.data() + encrypted_len);
+  // EXPECT_EQ(encrypted_vec, ct);
+
+  // Test the recipient.
+  bssl::ScopedEVP_HPKE_KEY base_key;
+  ASSERT_TRUE(EVP_HPKE_KEY_init(base_key.get(), kem, secret_key_r_.data(),
+                                secret_key_r_.size()));
+
+  const EVP_HPKE_KEY *key = base_key.get();
+
+  uint8_t public_key[EVP_HPKE_MAX_PUBLIC_KEY_LENGTH];
+  size_t public_key_len;
+  EXPECT_TRUE(EVP_HPKE_KEY_public_key(key, public_key, &public_key_len,
+                                      sizeof(public_key)));
+  std::vector<uint8_t> public_key_vec(public_key, public_key + public_key_len);
+  EXPECT_EQ(public_key_vec, public_key_r_);
+
+  // Now the same with the private key
+  uint8_t secret_key[EVP_HPKE_MAX_PRIVATE_KEY_LENGTH];
+  size_t secret_key_len;
+  EXPECT_TRUE(EVP_HPKE_KEY_private_key(key, secret_key, &secret_key_len,
+                                       sizeof(secret_key)));
+  std::vector<uint8_t> secret_key_vec(secret_key, secret_key + secret_key_len);
+  EXPECT_EQ(secret_key_vec, secret_key_r_);
+
+  // Set up the recipient
+  bssl::ScopedEVP_HPKE_CTX recipient_ctx;
+  EXPECT_TRUE(EVP_HPKE_CTX_setup_recipient(recipient_ctx.get(), key, kdf,
+                                           aead, enc, enc_len, info_.data(),
+                                           info_.size()));
+
+  // Verify Decryption
+  std::vector<uint8_t> decrypted(ct.size());
+  size_t decrypted_len;
+  EXPECT_EQ(1, EVP_HPKE_CTX_open(recipient_ctx.get(), decrypted.data(),
+                                  &decrypted_len, decrypted.size(),
+                                  encrypted.data(), encrypted_len, aad.data(),
+                                  aad.size()));
+  std::vector<uint8_t> decrypted_vec(decrypted.data(), decrypted.data() + decrypted_len);
+  EXPECT_EQ(decrypted_vec, pt);
+}
+
+// Test a sample function to make sure build is setup correctly.
+TEST(OhttpTest, TestOHTTPDetected) {
+  EXPECT_EQ(ohttp::GetFoo(), "foo");
+}
+
+// Test encoding strings.
+TEST(EncodeStringTest, TestEncodeString) {
+  std::string input = "hello";
+  // Length is a 2-byte number.
+  std::vector<uint8_t> expected = {5, 'h', 'e', 'l', 'l', 'o'};
+  EXPECT_EQ(ohttp::encode_string(input), expected);
+}
+
+// Test extracting encoded strings.
+TEST(DecodeStringTest, TestDecodeString) {
+  int starting_offset = 0;
+  std::vector<uint8_t> input = {5, 0x42, 0x43, 0x44, 0x45, 0x46, 1, 0x47};
+  std::vector<uint8_t> expected = {0x42, 0x43, 0x44, 0x45, 0x46};
+  std::vector<uint8_t> output;
+  int bytes_used;
+  EXPECT_EQ(ohttp::get_next_encoded_string(input, starting_offset, output, bytes_used), ohttp::OhttpParseErrorCode::SUCCESS);
+  EXPECT_EQ(output, expected);
+  EXPECT_EQ(bytes_used, 6);
+  int next_offset = starting_offset + bytes_used;
+  expected = {0x47};
+  std::vector<uint8_t> output2;
+  EXPECT_EQ(ohttp::get_next_encoded_string(input, next_offset, output2, bytes_used), ohttp::OhttpParseErrorCode::SUCCESS);
+  EXPECT_EQ(output2, expected);
+  EXPECT_EQ(bytes_used, 2);
+}
+
+// Test binary request creation per https://www.rfc-editor.org/rfc/rfc9292
+TEST(OhttpTest, TestBinaryRequest) {
+  std::vector<uint8_t> request =
+      ohttp::get_binary_request("/", "ohttp-gateway.jthess.com", "foo");
+  std::vector<uint8_t> expected = {
+      // Known-Length Request {
+      //   Framing Indicator (i) = 0,
+      //   Request Control Data (..),
+      //   Known-Length Field Section (..),
+      //   Known-Length Content (..),
+      //   Known-Length Field Section (..),
+      //   Padding (..),
+      // }
+
+      // Framing Indicator
+      0,
+
+      // Control Data
+      // Request Control Data {
+      //   Method Length (i),
+      4,
+      //   Method (..),
+      'P', 'O', 'S', 'T',  // Method Length & Method
+      //   Scheme Length (i),
+      5,
+      //   Scheme (..),
+      'h', 't', 't', 'p', 's',
+      //   Authority Length (i),
+      24,
+      //   Authority (..),
+      'o', 'h', 't', 't', 'p', '-', 'g', 'a', 't', 'e', 'w', 'a', 'y', '.', 'j',
+      't', 'h', 'e', 's', 's', '.', 'c', 'o', 'm',
+      //   Path Length (i),
+      1,
+      //   Path (..),
+      // }
+      '/',
+
+      // Header section.
+      // Known-Length Field Section {
+      //   Length (i),
+      0,
+      //   Field Line (..) ...,
+      // }
+
+      // Known-Length Content {
+      //   Content Length (i),
+      3,
+      //   Content (..),
+      'f', 'o', 'o',
+      // }
+
+      // Trailer section.
+      // Known-Length Field Section {
+      //   Length (i),
+      0,
+      //   Field Line (..) ...,
+      // }
+  };
+  EXPECT_EQ(request, expected);
+}
+
+// Test that encapsulation starts with the correct header.
+TEST(OhttpTest, TestEncapsulatedRequestHeader) {
+  // Encapsulation per RFC 9458:
+  // https://www.rfc-editor.org/rfc/rfc9458
+
+  // hdr = concat(encode(1, key_id),
+  //              encode(2, kem_id),
+  //              encode(2, kdf_id),
+  //              encode(2, aead_id))
+  // info = concat(encode_str("message/bhttp request"),
+  //               encode(1, 0),
+  //               hdr)
+  // enc, sctxt = SetupBaseS(pkR, info)
+  // ct = sctxt.Seal("", request)
+  // enc_request = concat(hdr, enc, ct)
+
+  EVP_HPKE_KEY test_keypair = getKeys();
+  uint8_t pkR[EVP_HPKE_MAX_PUBLIC_KEY_LENGTH];
+  size_t pkR_len;
+  int rv = EVP_HPKE_KEY_public_key(
+      &test_keypair, pkR, &pkR_len, EVP_HPKE_MAX_PUBLIC_KEY_LENGTH);
+  EXPECT_EQ(rv, 1); // Check if public key retrieval was successful
+
+  std::vector<uint8_t> request =
+      ohttp::get_encapsulated_request("/", "ohttp-gateway.jthess.com", "foo", pkR, pkR_len);
+
+  std::vector<uint8_t> expected_hdr = {
+      0x80,        // Key ID
+      0x00, 0x20,  // HPKE KEM ID
+      0x00, 0x01,  // KDF ID
+      0x00, 0x01,  // AEAD ID
+  };
+
+  // hdr portion of the encapsulated request is the first 7 bytes of request.
+  int hdr_length = 7;
+  std::vector<uint8_t> actual_hdr(hdr_length);
+  std::copy(request.begin() + 0, request.begin() + hdr_length,
+            actual_hdr.begin());
+  EXPECT_EQ(expected_hdr, actual_hdr);
+
+  // enc and ct vary.  Their creation is outsourced to HPKE implementation from
+  // openssl.
+}
+
+TEST(OhttpTest, DecapsulateEmptyRequestFails) {
+  EVP_HPKE_KEY test_keypair = getKeys();
+  size_t pkR_len = 32;
+  uint8_t pkR[pkR_len];
+  size_t written;
+  int rv = EVP_HPKE_KEY_public_key(
+      &test_keypair, pkR, &written, pkR_len);
+  EXPECT_EQ(rv, 1); // Check if public key retrieval was successful
+
+  // Now, decapsulate it with the same keypair
+  std::vector<uint8_t> empty_request = {};
+  std::vector<uint8_t> request_bhttp(0);
+  size_t out_len;
+  ohttp::DecapsulationErrorCode rv2 = ohttp::decapsulate_request(
+    empty_request, request_bhttp.data(), &out_len, 0, test_keypair);
+  EXPECT_EQ(rv2, ohttp::DecapsulationErrorCode::ERR_NO_ENCAPSULATED_HEADER);
+}
+
+// Enc/Decapsulate routrip test
+TEST(OhttpTest, EncapsulateAndDecapsulateRequest) {
+  // Recipient keys
+  EVP_HPKE_KEY test_keypair = getKeys();
+  uint8_t pkR[EVP_HPKE_MAX_PUBLIC_KEY_LENGTH];
+  size_t pkR_len;
+  int rv = EVP_HPKE_KEY_public_key(
+      &test_keypair, pkR, &pkR_len, EVP_HPKE_MAX_PUBLIC_KEY_LENGTH);
+  EXPECT_EQ(rv, 1); // Check if public key retrieval was successful
+
+  // Encapsulate it
+  std::vector<uint8_t> request =
+      ohttp::get_encapsulated_request("/", "ohttp-gateway.jthess.com", "foo", pkR, pkR_len);
+
+  size_t max_out_len = request.size();
+  std::vector<uint8_t> request_bhttp(max_out_len);
+  size_t out_len;
+  ohttp::DecapsulationErrorCode rv2 = ohttp::decapsulate_request(
+    request, request_bhttp.data(), &out_len, max_out_len, test_keypair);
+  EXPECT_EQ(rv2, ohttp::DecapsulationErrorCode::SUCCESS);
+
+  std::vector<uint8_t> expected_bhttp = ohttp::get_binary_request("/", "ohttp-gateway.jthess.com", "foo");
+  EXPECT_EQ(out_len, expected_bhttp.size());
+  std::vector<uint8_t> request_bhttp_vec(request_bhttp.data(), request_bhttp.data() + out_len);
+  EXPECT_EQ(request_bhttp_vec, expected_bhttp);
+}
+
+}  // namespace
+
+int main(int argc, char** argv) {
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
\ No newline at end of file
